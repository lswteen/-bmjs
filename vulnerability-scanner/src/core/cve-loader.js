import fs from 'fs/promises';
import path from 'path';
import { findFiles } from './file-utils.js';
import { config } from './config.js';

/**
 * Load and parse CVE data from JSON files
 */
export class CVELoader {
    constructor(basePath = config.cveBasePath, specificMode = false) {
        this.basePath = basePath;
        this.specificMode = specificMode;
        this.cveCache = [];
        this.cveIndex = new Map(); // Index by product: "vendor:product" -> [cves]
        this.stats = {
            totalFiles: 0,
            loadedCVEs: 0,
            javaRelevantCVEs: 0
        };
    }

    /**
     * Load all CVEs from specified years
     */
    async loadAll() {
        console.log(`ðŸ” Loading CVE data from: ${this.basePath}`);

        try {
            let years = [];

            if (this.specificMode && config.specificCVEs.length > 0) {
                // In specific mode, only load years derived from the target CVE IDs
                // Format: CVE-YYYY-NNNN
                const targetYears = new Set(
                    config.specificCVEs
                        .map(id => {
                            const match = id.match(/CVE-(\d{4})-/);
                            return match ? match[1] : null;
                        })
                        .filter(y => y !== null)
                );
                years = Array.from(targetYears).sort();
                console.log(`ðŸŽ¯ Specific Mode: Scanning only for years: ${years.join(', ')}`);
            } else if (config.cveYears && config.cveYears.length > 0) {
                // Respect configured years if provided
                years = [...config.cveYears].sort();
                console.log(`ðŸ“… Configured Years: ${years.join(', ')}`);
            } else {
                // Auto-discover years
                const entries = await fs.readdir(this.basePath, { withFileTypes: true });
                years = entries
                    .filter(ent => ent.isDirectory() && /^\d{4}$/.test(ent.name))
                    .map(ent => ent.name)
                    .sort();
                console.log(`ðŸ“… Discovered Years: ${years.join(', ')}`);
            }

            for (const year of years) {
                const yearPath = path.join(this.basePath, year);
                try {
                    await this.loadYear(yearPath, year);
                } catch (error) {
                    console.warn(`âš ï¸  Warning: Could not load CVEs from ${year}: ${error.message}`);
                }
            }
        } catch (error) {
            console.error(`âŒ Error scanning CVE base path: ${error.message}`);
        }

        console.log(`âœ… Loaded ${this.stats.javaRelevantCVEs} Java-relevant CVEs from ${this.stats.totalFiles} files`);
        return this.cveCache;
    }

    /**
     * Load CVEs from a specific year directory
     */
    async loadYear(yearPath, year) {
        const files = await findFiles(yearPath, '*.json');

        console.log(`  ðŸ“‚ ${year}: Found ${files.length} CVE files`);

        for (const file of files) {
            try {
                const data = await fs.readFile(file, 'utf8');
                const cve = JSON.parse(data);

                this.stats.totalFiles++;

                // Progress feedback (every 1000 files)
                if (this.stats.totalFiles % 1000 === 0) {
                    process.stdout.write(`\r  â³ Progress: ${this.stats.totalFiles} files processed (${this.stats.javaRelevantCVEs} matched)...`);
                }

                // Check specific filter
                const cveId = cve.cveMetadata?.cveId;
                if (this.specificMode && config.specificCVEs.length > 0) {
                    if (!config.specificCVEs.includes(cveId)) {
                        continue; // Skip if not in target list
                    }
                }

                if (this.isRelevant(cve)) {
                    const normalized = this.normalizeCVE(cve);
                    this.cveCache.push(normalized);
                    this.addToIndex(normalized);
                    this.stats.javaRelevantCVEs++;
                }
            } catch (error) {
                // Skip malformed JSON files
                // console.warn(`  âš ï¸  Skipping ${path.basename(file)}: ${error.message}`);
            }
        }
    }

    /**
     * Check if CVE is relevant to enabled ecosystems
     */
    isRelevant(cve) {
        // If filter mode is 'all', skip filtering and include everything
        if (config.filterMode === 'all') return true;

        const cna = cve.containers?.cna || {};

        // Extract searchable text from key fields to avoid stringifying the entire object
        const description = (cna.descriptions?.[0]?.value || '').toLowerCase();
        const affected = (cna.affected || []).map(a =>
            `${a.vendor || ''} ${a.product || ''} ${a.packageName || ''}`.toLowerCase()
        ).join(' ');

        const searchableText = `${description} ${affected}`;

        // Check if any keyword from enabled ecosystems appears in the searchable text
        for (const [key, ecosystem] of Object.entries(config.ecosystems)) {
            if (ecosystem.enabled) {
                const match = ecosystem.keywords.some(keyword =>
                    searchableText.includes(keyword.toLowerCase())
                );
                if (match) return true;
            }
        }
        return false;
    }

    /**
     * Normalize CVE data structure for easier access
     */
    normalizeCVE(cve) {
        const cveId = cve.cveMetadata?.cveId || 'UNKNOWN';
        const cna = cve.containers?.cna || {};

        // Extract description
        const description = cna.descriptions?.[0]?.value || 'No description available';

        // Extract affected products
        const affected = (cna.affected || []).map(item => {
            const versions = (item.versions || []).map(v => {
                let range = v.version || '*';

                // Construct semver range if bounds are present
                // CVE JSON 5.0: version is usually the start version
                if (v.version !== '0' && v.version !== '*') {
                    range = `>=${v.version}`;
                }

                if (v.lessThan) {
                    range += ` <${v.lessThan}`;
                } else if (v.lessThanOrEqual) {
                    range += ` <=${v.lessThanOrEqual}`;
                }

                return {
                    version: v.version,
                    status: v.status,
                    lessThan: v.lessThan,
                    lessThanOrEqual: v.lessThanOrEqual,
                    range: range
                };
            });

            return {
                vendor: item.vendor || 'unknown',
                product: item.product || 'unknown',
                packageName: item.packageName || null,
                versions: versions
            };
        });

        // Extract CVSS score and severity
        let metrics = {};
        if (cna.metrics) {
            for (const m of cna.metrics) {
                if (m.cvssV4_0) {
                    metrics = m.cvssV4_0;
                    break;
                }
                if (m.cvssV3_1) {
                    metrics = m.cvssV3_1;
                    break;
                }
                if (m.cvssV3_0) {
                    metrics = m.cvssV3_0;
                    break;
                }
            }
        }

        const baseScore = metrics.baseScore || 0;
        const baseSeverity = metrics.baseSeverity || this.calculateSeverity(baseScore);

        // Extract references
        const references = (cna.references || []).map(ref => ref.url);

        // Extract CWE
        const problemTypes = cna.problemTypes || [];
        const cwes = problemTypes
            .flatMap(pt => pt.descriptions || [])
            .filter(desc => desc.type === 'CWE')
            .map(desc => desc.cweId);

        return {
            id: cveId,
            description,
            affected,
            cvss: {
                score: baseScore,
                severity: baseSeverity,
                vector: metrics.vectorString || 'N/A'
            },
            references,
            cwes,
            published: cve.cveMetadata?.datePublished || 'Unknown',
            updated: cve.cveMetadata?.dateUpdated || 'Unknown'
        };
    }

    /**
     * Calculate severity based on CVSS score
     */
    calculateSeverity(score) {
        if (score >= config.severityLevels.CRITICAL) return 'CRITICAL';
        if (score >= config.severityLevels.HIGH) return 'HIGH';
        if (score >= config.severityLevels.MEDIUM) return 'MEDIUM';
        if (score >= config.severityLevels.LOW) return 'LOW';
        return 'NONE';
    }

    /**
     * Get statistics about loaded CVEs
     */
    getStats() {
        return {
            ...this.stats,
            severityBreakdown: this.getSeverityBreakdown()
        };
    }

    /**
     * Get breakdown of CVEs by severity
     */
    getSeverityBreakdown() {
        const breakdown = {
            CRITICAL: 0,
            HIGH: 0,
            MEDIUM: 0,
            LOW: 0,
            NONE: 0
        };

        this.cveCache.forEach(cve => {
            const severity = cve.cvss.severity;
            breakdown[severity] = (breakdown[severity] || 0) + 1;
        });

        return breakdown;
    }

    /**
     * Search CVEs by product and vendor
     */
    searchByProduct(product, vendor = null) {
        return this.cveCache.filter(cve => {
            return cve.affected.some(affected => {
                const productMatch = affected.product.toLowerCase().includes(product.toLowerCase());
                const vendorMatch = !vendor || affected.vendor.toLowerCase().includes(vendor.toLowerCase());
                return productMatch && vendorMatch;
            });
        });
    }

    /**
     * Get all loaded CVEs
     */
    getAllCVEs() {
        return this.cveCache;
    }

    /**
     * Add CVE to search index
     */
    addToIndex(cve) {
        const processedProducts = new Set();

        cve.affected.forEach(item => {
            const product = item.product.toLowerCase();
            // Store by exact name
            this._addToIndex(product, cve);

            // Store by normalized name (remove symbols)
            const normalized = this.normalizeProduct(product);
            if (normalized !== product) {
                this._addToIndex(normalized, cve);
            }

            // Store by Package Name (e.g. org.apache.tika:tika-core)
            if (item.packageName) {
                const pkgName = item.packageName.toLowerCase();
                this._addToIndex(pkgName, cve);

                // Also index by Artifact ID part (e.g. tika-core)
                if (pkgName.includes(':')) {
                    const parts = pkgName.split(':');
                    if (parts.length === 2) {
                        this._addToIndex(parts[1], cve);
                    }
                }
            }
        });
    }

    _addToIndex(key, cve) {
        if (!this.cveIndex.has(key)) {
            this.cveIndex.set(key, []);
        }
        this.cveIndex.get(key).push(cve);
    }

    /**
     * Get CVEs for a specific product matching (O(1) lookup)
     */
    getCVEsForProduct(product) {
        const exact = this.cveIndex.get(product.toLowerCase()) || [];
        const normalized = this.cveIndex.get(this.normalizeProduct(product)) || [];

        // Return combined list (Set removes duplicates)
        return [...new Set([...exact, ...normalized])];
    }

    normalizeProduct(name) {
        return name.toLowerCase().replace(/[^a-z0-9]/g, '');
    }
}
