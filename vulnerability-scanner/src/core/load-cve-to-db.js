import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';
import { cveDb } from './cve-db.js';
import { findFiles } from './file-utils.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Base path from existing config or defaults
const CVE_BASE_PATH = '/Users/milk/workspace/-bmjs/cves';

async function loadAllCves() {
    console.log('ðŸš€ Starting CVE Migration to SQLite...');
    await cveDb.init();

    try {
        const entries = await fs.readdir(CVE_BASE_PATH, { withFileTypes: true });
        const years = entries
            .filter(ent => ent.isDirectory() && /^\d{4}$/.test(ent.name))
            .map(ent => ent.name)
            .sort();

        console.log(`ðŸ“… Found years: ${years.join(', ')}`);

        let totalLoaded = 0;

        for (const year of years) {
            console.log(`ðŸ“‚ Processing year: ${year}...`);
            const yearPath = path.join(CVE_BASE_PATH, year);
            const files = await findFiles(yearPath, '*.json');

            let yearCount = 0;
            for (const file of files) {
                try {
                    const data = await fs.readFile(file, 'utf8');
                    const raw = JSON.parse(data);

                    const normalized = normalizeCve(raw);
                    if (normalized) {
                        await cveDb.insertCve(normalized);
                        yearCount++;
                    }
                } catch (e) {
                    // Skip errors
                }
            }
            totalLoaded += yearCount;
            console.log(`âœ… ${year} complete: ${yearCount} records loaded.`);
        }

        const stats = await cveDb.getStats();
        console.log(`\nâœ¨ Migration complete! Total records in DB: ${stats.count}`);
    } catch (error) {
        console.error('âŒ Migration failed:', error);
    } finally {
        cveDb.close();
    }
}

function normalizeCve(raw) {
    try {
        const cveId = raw.cveMetadata?.cveId;
        if (!cveId) return null;

        const cna = raw.containers?.cna || {};
        const description = cna.descriptions?.[0]?.value || '';

        let score = 0;
        let severity = 'UNKNOWN';

        if (cna.metrics) {
            const m = cna.metrics[0];
            const cvss = m.cvssV3_1 || m.cvssV3_0 || m.cvssV4_0;
            if (cvss) {
                score = cvss.baseScore || 0;
                severity = cvss.baseSeverity || 'UNKNOWN';
            }
        }

        let vendor = 'unknown';
        let product = 'unknown';
        if (cna.affected && cna.affected.length > 0) {
            vendor = cna.affected[0].vendor || 'unknown';
            product = cna.affected[0].product || 'unknown';
        }

        const datePublished = raw.cveMetadata?.datePublished || 'Unknown';

        return {
            cveId,
            description,
            cvssScore: score,
            severity,
            vendor,
            product,
            datePublished
        };
    } catch (e) {
        return null;
    }
}

loadAllCves();
