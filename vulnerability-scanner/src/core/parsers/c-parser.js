import fs from 'fs/promises';
import path from 'path';

/**
 * Parser for C/C++ projects (CMake, Conan)
 */
export class CParser {
    constructor() { }

    /**
     * Check if directory involves C/C++ build files
     */
    async isApplicable(dir) {
        try {
            const files = await fs.readdir(dir);
            return files.includes('CMakeLists.txt') ||
                files.includes('conanfile.txt') ||
                files.includes('conanfile.py');
        } catch {
            return false;
        }
    }

    /**
     * Parse project dependencies
     */
    async parse(projectPath) { // projectPath is expected to be file path (e.g. CMakeLists.txt)
        const filename = path.basename(projectPath);
        const content = await fs.readFile(projectPath, 'utf-8');
        const dependencies = [];

        if (filename === 'CMakeLists.txt') {
            dependencies.push(...this.parseCMake(content));
        } else if (filename.startsWith('conanfile')) {
            dependencies.push(...this.parseConan(content));
        }

        return {
            name: path.basename(path.dirname(projectPath)), // Project Name from folder
            artifactId: path.basename(path.dirname(projectPath)),
            groupId: 'cpp_project',
            version: '0.0.0', // Detection hard without specific file
            type: 'c_cpp',
            dependencies: dependencies
        };
    }

    /**
     * Parse CMakeLists.txt for find_package calls
     */
    parseCMake(content) {
        const dependencies = [];
        // Regex for: find_package(OpenSSL 1.1.1 REQUIRED) or find_package(Boost 1.70)
        // Groups: 1=Name, 2=Version (optional)
        const regex = /find_package\s*\(\s*([a-zA-Z0-9_]+)(?:\s+([0-9.]+))?/gi;

        let match;
        while ((match = regex.exec(content)) !== null) {
            const name = match[1];
            const version = match[2] || 'unknown';

            // Filter out internal system packages if needed, but for now capture all
            dependencies.push({
                groupId: 'c_cpp_lib',
                artifactId: name.toLowerCase(),
                version: version
            });
        }
        return dependencies;
    }

    /**
     * Parse conanfile.txt for [requires]
     */
    parseConan(content) {
        const dependencies = [];
        const lines = content.split('\n');
        let inRequires = false;

        for (const line of lines) {
            const trimLine = line.trim();
            if (trimLine === '[requires]') {
                inRequires = true;
                continue;
            } else if (trimLine.startsWith('[')) {
                inRequires = false;
            }

            if (inRequires && trimLine) {
                // Format: package/version or package/version@user/channel
                // e.g., openssl/1.1.1u
                const parts = trimLine.split('/');
                if (parts.length >= 2) {
                    dependencies.push({
                        groupId: 'conan_lib',
                        artifactId: parts[0].toLowerCase(),
                        version: parts[1].split('@')[0] // remove @user/channel if present
                    });
                }
            }
        }
        return dependencies;
    }
}
