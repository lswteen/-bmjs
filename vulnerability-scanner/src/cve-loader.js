import fs from 'fs/promises';
import path from 'path';
import { findFiles } from './file-utils.js';
import { config } from './config.js';

/**
 * Load and parse CVE data from JSON files
 */
export class CVELoader {
    constructor(basePath = config.cveBasePath) {
        this.basePath = basePath;
        this.cveCache = [];
        this.stats = {
            totalFiles: 0,
            loadedCVEs: 0,
            javaRelevantCVEs: 0
        };
    }

    /**
     * Load all CVEs from specified years
     */
    async loadAll() {
        console.log(`ðŸ” Loading CVE data from: ${this.basePath}`);

        try {
            // Auto-discover years
            const entries = await fs.readdir(this.basePath, { withFileTypes: true });
            const years = entries
                .filter(ent => ent.isDirectory() && /^\d{4}$/.test(ent.name))
                .map(ent => ent.name)
                .sort();

            console.log(`ðŸ“… Found Cve Years: ${years.join(', ')}`);

            for (const year of years) {
                const yearPath = path.join(this.basePath, year);
                try {
                    await this.loadYear(yearPath, year);
                } catch (error) {
                    console.warn(`âš ï¸  Warning: Could not load CVEs from ${year}: ${error.message}`);
                }
            }
        } catch (error) {
            console.error(`âŒ Error scanning CVE base path: ${error.message}`);
        }

        console.log(`âœ… Loaded ${this.stats.javaRelevantCVEs} Java-relevant CVEs from ${this.stats.totalFiles} files`);
        return this.cveCache;
    }

    /**
     * Load CVEs from a specific year directory
     */
    async loadYear(yearPath, year) {
        const files = await findFiles(yearPath, '*.json');

        console.log(`  ðŸ“‚ ${year}: Found ${files.length} CVE files`);

        for (const file of files) {
            try {
                const data = await fs.readFile(file, 'utf8');
                const cve = JSON.parse(data);

                this.stats.totalFiles++;

                if (this.isRelevant(cve)) {
                    const normalized = this.normalizeCVE(cve);
                    this.cveCache.push(normalized);
                    this.stats.javaRelevantCVEs++;
                }
            } catch (error) {
                // Skip malformed JSON files
                // console.warn(`  âš ï¸  Skipping ${path.basename(file)}: ${error.message}`);
            }
        }
    }

    /**
     * Check if CVE is relevant to enabled ecosystems
     */
    isRelevant(cve) {
        // If filter mode is 'all', skip filtering and include everything
        if (config.filterMode === 'all') return true;

        const cveText = JSON.stringify(cve).toLowerCase();

        // Check if any keyword from enabled ecosystems appears in the CVE
        for (const [key, ecosystem] of Object.entries(config.ecosystems)) {
            if (ecosystem.enabled) {
                const match = ecosystem.keywords.some(keyword =>
                    cveText.includes(keyword.toLowerCase())
                );
                if (match) return true;
            }
        }
        return false;
    }

    /**
     * Normalize CVE data structure for easier access
     */
    normalizeCVE(cve) {
        const cveId = cve.cveMetadata?.cveId || 'UNKNOWN';
        const cna = cve.containers?.cna || {};

        // Extract description
        const description = cna.descriptions?.[0]?.value || 'No description available';

        // Extract affected products
        const affected = (cna.affected || []).map(item => ({
            vendor: item.vendor || 'unknown',
            product: item.product || 'unknown',
            versions: item.versions || []
        }));

        // Extract CVSS score and severity
        const metrics = cna.metrics?.[0]?.cvssV3_1 || cna.metrics?.[0]?.cvssV3_0 || {};
        const baseScore = metrics.baseScore || 0;
        const baseSeverity = metrics.baseSeverity || this.calculateSeverity(baseScore);

        // Extract references
        const references = (cna.references || []).map(ref => ref.url);

        // Extract CWE
        const problemTypes = cna.problemTypes || [];
        const cwes = problemTypes
            .flatMap(pt => pt.descriptions || [])
            .filter(desc => desc.type === 'CWE')
            .map(desc => desc.cweId);

        return {
            id: cveId,
            description,
            affected,
            cvss: {
                score: baseScore,
                severity: baseSeverity,
                vector: metrics.vectorString || 'N/A'
            },
            references,
            cwes,
            published: cve.cveMetadata?.datePublished || 'Unknown',
            updated: cve.cveMetadata?.dateUpdated || 'Unknown'
        };
    }

    /**
     * Calculate severity based on CVSS score
     */
    calculateSeverity(score) {
        if (score >= config.severityLevels.CRITICAL) return 'CRITICAL';
        if (score >= config.severityLevels.HIGH) return 'HIGH';
        if (score >= config.severityLevels.MEDIUM) return 'MEDIUM';
        if (score >= config.severityLevels.LOW) return 'LOW';
        return 'NONE';
    }

    /**
     * Get statistics about loaded CVEs
     */
    getStats() {
        return {
            ...this.stats,
            severityBreakdown: this.getSeverityBreakdown()
        };
    }

    /**
     * Get breakdown of CVEs by severity
     */
    getSeverityBreakdown() {
        const breakdown = {
            CRITICAL: 0,
            HIGH: 0,
            MEDIUM: 0,
            LOW: 0,
            NONE: 0
        };

        this.cveCache.forEach(cve => {
            const severity = cve.cvss.severity;
            breakdown[severity] = (breakdown[severity] || 0) + 1;
        });

        return breakdown;
    }

    /**
     * Search CVEs by product and vendor
     */
    searchByProduct(product, vendor = null) {
        return this.cveCache.filter(cve => {
            return cve.affected.some(affected => {
                const productMatch = affected.product.toLowerCase().includes(product.toLowerCase());
                const vendorMatch = !vendor || affected.vendor.toLowerCase().includes(vendor.toLowerCase());
                return productMatch && vendorMatch;
            });
        });
    }

    /**
     * Get all loaded CVEs
     */
    getAllCVEs() {
        return this.cveCache;
    }
}
