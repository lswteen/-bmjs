/**
 * CVE Service Test
 * Unit tests for CVE Service following TDD/BDD principles
 */

/**
 * Mock CVE Repository for testing
 */
class MockCveRepository {
    constructor() {
        this.initialized = true;
        this.mockData = {
            rows: [
                {
                    id: 'CVE-2024-0001',
                    description: 'Test vulnerability',
                    publishedDate: '2024-01-01',
                    lastModifiedDate: '2024-01-02',
                    cvssScore: 7.5,
                    severity: 'HIGH'
                }
            ],
            total: 1,
            page: 1,
            pageSize: 50
        };
    }

    isInitialized() {
        return this.initialized;
    }

    async searchByFilters(filters, page, pageSize) {
        return this.mockData;
    }

    async getFilterOptions() {
        return {
            years: ['2024', '2023'],
            severities: ['HIGH', 'MEDIUM', 'LOW']
        };
    }

    async getVisualData(year, severity) {
        return [{ year: '2024', count: 100 }];
    }

    async getDetailedCveList(year, severity, page, pageSize) {
        return this.mockData;
    }
}

/**
 * Test Suite for CVE Service
 */
export class CveServiceTest {
    constructor() {
        this.mockRepository = new MockCveRepository();
    }

    /**
     * Run all tests
     */
    async runAll() {
        console.log('ðŸ§ª Running CVE Service Tests...\n');

        const tests = [
            this.testIsInitialized.bind(this),
            this.testSearchByFilters.bind(this),
            this.testGetFilterOptions.bind(this),
            this.testGetVisualData.bind(this),
            this.testGetDetailedCveList.bind(this)
        ];

        let passed = 0;
        let failed = 0;

        for (const test of tests) {
            try {
                await test();
                passed++;
            } catch (error) {
                failed++;
                console.error(`âŒ Test failed: ${error.message}\n`);
            }
        }

        console.log(`\nðŸ“Š Test Results: ${passed} passed, ${failed} failed`);
        return { passed, failed };
    }

    /**
     * Test: isInitialized should return repository initialization status
     */
    async testIsInitialized() {
        // Given
        const { CveService } = await import('../services/CveService.js');
        const service = new CveService(this.mockRepository);

        // When
        const result = service.isInitialized();

        // Then
        this.assert(result === true, 'isInitialized should return true');
        console.log('âœ… testIsInitialized passed');
    }

    /**
     * Test: searchByFilters should return filtered CVE data
     */
    async testSearchByFilters() {
        // Given
        const { CveService } = await import('../services/CveService.js');
        const service = new CveService(this.mockRepository);
        const filters = { cveId: 'CVE-2024-0001' };

        // When
        const result = await service.searchByFilters(filters, 1, 50);

        // Then
        this.assert(result.rows.length > 0, 'Should return CVE data');
        this.assert(result.rows[0].id === 'CVE-2024-0001', 'Should return correct CVE');
        console.log('âœ… testSearchByFilters passed');
    }

    /**
     * Test: getFilterOptions should return available filter options
     */
    async testGetFilterOptions() {
        // Given
        const { CveService } = await import('../services/CveService.js');
        const service = new CveService(this.mockRepository);

        // When
        const result = await service.getFilterOptions();

        // Then
        this.assert(result.years.length > 0, 'Should return years');
        this.assert(result.severities.length > 0, 'Should return severities');
        console.log('âœ… testGetFilterOptions passed');
    }

    /**
     * Test: getVisualData should return data for visualization
     */
    async testGetVisualData() {
        // Given
        const { CveService } = await import('../services/CveService.js');
        const service = new CveService(this.mockRepository);

        // When
        const result = await service.getVisualData('2024', 'HIGH');

        // Then
        this.assert(Array.isArray(result), 'Should return array');
        this.assert(result.length > 0, 'Should return data');
        console.log('âœ… testGetVisualData passed');
    }

    /**
     * Test: getDetailedCveList should return detailed CVE list
     */
    async testGetDetailedCveList() {
        // Given
        const { CveService } = await import('../services/CveService.js');
        const service = new CveService(this.mockRepository);

        // When
        const result = await service.getDetailedCveList('2024', 'HIGH', 1, 50);

        // Then
        this.assert(result.rows.length > 0, 'Should return CVE data');
        this.assert(result.total > 0, 'Should return total count');
        console.log('âœ… testGetDetailedCveList passed');
    }

    /**
     * Simple assertion helper
     */
    assert(condition, message) {
        if (!condition) {
            throw new Error(message);
        }
    }
}

// Run tests if executed directly
if (import.meta.url === `file://${process.argv[1]}`) {
    const test = new CveServiceTest();
    test.runAll().then(results => {
        process.exit(results.failed > 0 ? 1 : 0);
    });
}
