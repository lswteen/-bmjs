/**
 * Scan Service Test
 * Unit tests for Scan Service following TDD/BDD principles
 */

/**
 * Mock Scanner for testing
 */
class MockScanner {
    async scan() {
        return {
            projects: [
                {
                    key: 'test-project',
                    name: 'Test Project',
                    vulnerabilities: [
                        {
                            cveId: 'CVE-2024-0001',
                            severity: 'HIGH'
                        }
                    ]
                }
            ],
            summary: {
                totalProjects: 1,
                totalVulnerabilities: 1
            }
        };
    }
}

/**
 * Test Suite for Scan Service
 */
export class ScanServiceTest {
    constructor() {
        this.mockScanner = new MockScanner();
        this.outputPath = '/tmp/test-output';
    }

    /**
     * Setup test environment
     */
    async setup() {
        const fs = await import('fs/promises');
        try {
            await fs.mkdir(this.outputPath, { recursive: true });
        } catch (error) {
            // Directory might already exist
        }
    }

    /**
     * Run all tests
     */
    async runAll() {
        console.log('ðŸ§ª Running Scan Service Tests...\n');

        // Setup
        await this.setup();

        const tests = [
            this.testPerformScan.bind(this),
            this.testGetStatus.bind(this),
            this.testGetProjects.bind(this),
            this.testGetProjectVulnerabilities.bind(this),
            this.testPreventConcurrentScans.bind(this)
        ];

        let passed = 0;
        let failed = 0;

        for (const test of tests) {
            try {
                await test();
                passed++;
            } catch (error) {
                failed++;
                console.error(`âŒ Test failed: ${error.message}\n`);
            }
        }

        console.log(`\nðŸ“Š Test Results: ${passed} passed, ${failed} failed`);
        return { passed, failed };
    }

    /**
     * Test: performScan should execute scan and return results
     */
    async testPerformScan() {
        // Given
        const { ScanService } = await import('../services/ScanService.js');
        const service = new ScanService(this.mockScanner, this.outputPath);

        // When
        const result = await service.performScan();

        // Then
        this.assert(result.projects.length > 0, 'Should return projects');
        this.assert(result.summary.totalProjects === 1, 'Should have correct project count');
        console.log('âœ… testPerformScan passed');
    }

    /**
     * Test: getStatus should return current scan status
     */
    async testGetStatus() {
        // Given
        const { ScanService } = await import('../services/ScanService.js');
        const service = new ScanService(this.mockScanner, this.outputPath);

        // When
        const status = service.getStatus();

        // Then
        this.assert(typeof status.isScanning === 'boolean', 'Should have isScanning property');
        this.assert(typeof status.hasResults === 'boolean', 'Should have hasResults property');
        console.log('âœ… testGetStatus passed');
    }

    /**
     * Test: getProjects should return scanned projects
     */
    async testGetProjects() {
        // Given
        const { ScanService } = await import('../services/ScanService.js');
        const service = new ScanService(this.mockScanner, this.outputPath);
        await service.performScan();

        // When
        const projects = await service.getProjects();

        // Then
        this.assert(Array.isArray(projects), 'Should return array');
        this.assert(projects.length > 0, 'Should have projects');
        console.log('âœ… testGetProjects passed');
    }

    /**
     * Test: getProjectVulnerabilities should return vulnerabilities for a project
     */
    async testGetProjectVulnerabilities() {
        // Given
        const { ScanService } = await import('../services/ScanService.js');
        const service = new ScanService(this.mockScanner, this.outputPath);
        await service.performScan();

        // When
        const vulnerabilities = await service.getProjectVulnerabilities('test-project');

        // Then
        this.assert(Array.isArray(vulnerabilities), 'Should return array');
        this.assert(vulnerabilities.length > 0, 'Should have vulnerabilities');
        console.log('âœ… testGetProjectVulnerabilities passed');
    }

    /**
     * Test: performScan should prevent concurrent scans
     */
    async testPreventConcurrentScans() {
        // Given
        const { ScanService } = await import('../services/ScanService.js');
        const service = new ScanService(this.mockScanner, this.outputPath);

        // When
        const scan1Promise = service.performScan();

        // Then
        try {
            await service.performScan();
            throw new Error('Should have thrown error for concurrent scan');
        } catch (error) {
            this.assert(
                error.message.includes('already in progress'),
                'Should prevent concurrent scans'
            );
        }

        await scan1Promise; // Wait for first scan to complete
        console.log('âœ… testPreventConcurrentScans passed');
    }

    /**
     * Simple assertion helper
     */
    assert(condition, message) {
        if (!condition) {
            throw new Error(message);
        }
    }
}

// Run tests if executed directly
if (import.meta.url === `file://${process.argv[1]}`) {
    const test = new ScanServiceTest();
    test.runAll().then(results => {
        process.exit(results.failed > 0 ? 1 : 0);
    });
}
