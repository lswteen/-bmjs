// Global state
let allProjects = [];
let filteredProjects = [];
let currentSort = { column: null, ascending: true };
let activeCveFilters = [];

// Initialize dashboard
async function init() {
  setupEventListeners();
  await loadResults();
}

// Setup event listeners
function setupEventListeners() {
  document.getElementById('scanBtn').addEventListener('click', triggerScan);
  document.getElementById('refreshBtn').addEventListener('click', loadResults);
  document.getElementById('searchInput').addEventListener('input', filterProjects);
  document.getElementById('severityFilter').addEventListener('change', filterProjects);
  document.getElementById('addCveBtn').addEventListener('click', addCveFilter);
  document.getElementById('cveInput').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') addCveFilter();
  });

  // Setup table sorting
  document.querySelectorAll('.sortable').forEach(th => {
    th.addEventListener('click', () => sortTable(th.dataset.sort));
  });
}

// Load scan results from API
async function loadResults() {
  try {
    showLoading(true);
    const response = await fetch('/api/results');
    const result = await response.json();

    if (result.success && result.data) {
      allProjects = result.data.projects || [];
      filteredProjects = [...allProjects];

      renderStats(result.data.statistics);
      renderProjectsTable();
    } else {
      showNoData(result.message || 'No scan results available');
    }
  } catch (error) {
    console.error('Failed to load results:', error);
    showNoData('Failed to load results. Please try again.');
  } finally {
    showLoading(false);
  }
}

// Trigger new scan
async function triggerScan() {
  const scanBtn = document.getElementById('scanBtn');

  try {
    scanBtn.disabled = true;
    scanBtn.innerHTML = '<span class="btn-icon">‚è≥</span><span class="btn-text">Scanning...</span>';

    const response = await fetch('/api/scan', { method: 'POST' });
    const result = await response.json();

    if (result.success) {
      showLoading(true);
      // Poll for completion
      await pollScanStatus();
      await loadResults();
    } else {
      alert(result.message || 'Failed to start scan');
    }
  } catch (error) {
    console.error('Scan error:', error);
    alert('Failed to start scan');
  } finally {
    scanBtn.disabled = false;
    scanBtn.innerHTML = '<span class="btn-icon">üîç</span><span class="btn-text">Run Scan</span>';
  }
}

// Poll scan status
async function pollScanStatus() {
  return new Promise((resolve) => {
    const interval = setInterval(async () => {
      try {
        const response = await fetch('/api/status');
        const status = await response.json();

        if (!status.isScanning && status.hasResults) {
          clearInterval(interval);
          resolve();
        }
      } catch (error) {
        console.error('Status poll error:', error);
      }
    }, 2000);
  });
}

// Render statistics cards
function renderStats(statistics) {
  if (!statistics || !statistics.vulnerabilities) return;

  const vulnerabilities = statistics.vulnerabilities;
  const statsHTML = `
    <div class="stat-card">
      <div class="stat-label">Total Projects</div>
      <div class="stat-value">${vulnerabilities.totalProjects || 0}</div>
    </div>
    <div class="stat-card">
      <div class="stat-label">Affected Projects</div>
      <div class="stat-value">${vulnerabilities.projectsWithVulnerabilities || 0}</div>
    </div>
    <div class="stat-card critical">
      <div class="stat-label">üî¥ Critical</div>
      <div class="stat-value">${vulnerabilities.bySeverity?.critical || 0}</div>
    </div>
    <div class="stat-card high">
      <div class="stat-label">üü† High</div>
      <div class="stat-value">${vulnerabilities.bySeverity?.high || 0}</div>
    </div>
    <div class="stat-card medium">
      <div class="stat-label">üü° Medium</div>
      <div class="stat-value">${vulnerabilities.bySeverity?.medium || 0}</div>
    </div>
    <div class="stat-card low">
      <div class="stat-label">üîµ Low</div>
      <div class="stat-value">${vulnerabilities.bySeverity?.low || 0}</div>
    </div>
  `;

  document.getElementById('statsCards').innerHTML = statsHTML;
}

// Render projects table
function renderProjectsTable() {
  const tbody = document.getElementById('projectsTableBody');

  if (filteredProjects.length === 0) {
    tbody.innerHTML = '<tr><td colspan="10" class="no-data">No projects found</td></tr>';
    return;
  }

  const rows = filteredProjects.map(project => {
    const p = project.project;
    const s = project.summary;
    const d = project.dependencies || { direct: 0, transitive: 0 };

    return `
      <tr>
        <td><code style="font-size: 0.85rem;">${escapeHtml(p.path)}</code></td>
        <td><strong>${escapeHtml(p.name)}</strong></td>
        <td><code>${escapeHtml(p.artifactId)}</code></td>
        <td style="text-align: center;">${d.direct}</td>
        <td style="text-align: center;">${d.transitive}</td>
        <td class="severity-col">
          <span class="severity-badge ${s.critical > 0 ? 'critical' : 'zero'}">
            ${s.critical || 0}
          </span>
        </td>
        <td class="severity-col">
          <span class="severity-badge ${s.high > 0 ? 'high' : 'zero'}">
            ${s.high || 0}
          </span>
        </td>
        <td class="severity-col">
          <span class="severity-badge ${s.medium > 0 ? 'medium' : 'zero'}">
            ${s.medium || 0}
          </span>
        </td>
        <td class="severity-col">
          <span class="severity-badge ${s.low > 0 ? 'low' : 'zero'}">
            ${s.low || 0}
          </span>
        </td>
        <td><strong>${s.total || 0}</strong></td>
        <td>
          <button class="btn-view" onclick="viewVulnerabilities('${escapeHtml(p.key)}')">
            View Details
          </button>
        </td>
      </tr>
    `;
  }).join('');

  tbody.innerHTML = rows;
}


// Add CVE Filter
function addCveFilter() {
  const input = document.getElementById('cveInput');
  const cveId = input.value.trim().toUpperCase();

  if (!cveId) return;

  if (activeCveFilters.length >= 10) {
    alert('Maximum 10 CVE filters allowed.');
    return;
  }

  if (activeCveFilters.includes(cveId)) {
    input.value = '';
    return;
  }

  activeCveFilters.push(cveId);
  input.value = '';
  renderCveTags();
  filterProjects();
}

// Remove CVE Filter
function removeCveFilter(cveId) {
  activeCveFilters = activeCveFilters.filter(id => id !== cveId);
  renderCveTags();
  filterProjects();
}

// Render CVE Tags
function renderCveTags() {
  const container = document.getElementById('cveTags');
  container.innerHTML = activeCveFilters.map(cve => `
    <div class="cve-tag">
      <span>${escapeHtml(cve)}</span>
      <span class="remove-tag" onclick="removeCveFilter('${escapeHtml(cve)}')">&times;</span>
    </div>
  `).join('');
}

// Filter projects
function filterProjects() {
  const searchTerm = document.getElementById('searchInput').value.toLowerCase();
  const severityFilter = document.getElementById('severityFilter').value;

  filteredProjects = allProjects.filter(project => {
    // Text search
    const matchesSearch = !searchTerm ||
      project.project.name.toLowerCase().includes(searchTerm) ||
      project.project.key.toLowerCase().includes(searchTerm) ||
      (project.project.path && project.project.path.toLowerCase().includes(searchTerm));

    // CVE Filter (OR logic: if any selected CVE is present)
    // If no active filters, this passes. If filters exist, project must match at least one.
    const matchesCve = activeCveFilters.length === 0 ||
      project.vulnerabilities.some(v => activeCveFilters.some(filter => v.cveId.toUpperCase().includes(filter)));

    // Severity filter
    const matchesSeverity = !severityFilter ||
      project.summary[severityFilter] > 0;

    return matchesSearch && matchesSeverity && matchesCve;
  });

  renderProjectsTable();
}

// Sort table
function sortTable(column) {
  if (currentSort.column === column) {
    currentSort.ascending = !currentSort.ascending;
  } else {
    currentSort.column = column;
    currentSort.ascending = true;
  }

  filteredProjects.sort((a, b) => {
    let aVal, bVal;

    if (['critical', 'high', 'medium', 'low'].includes(column)) {
      aVal = a.summary[column] || 0;
      bVal = b.summary[column] || 0;
    } else if (column === 'directDeps') {
      aVal = a.dependencies?.direct || 0;
      bVal = b.dependencies?.direct || 0;
    } else if (column === 'transitiveDeps') {
      aVal = a.dependencies?.transitive || 0;
      bVal = b.dependencies?.transitive || 0;
    } else if (column === 'artifactId') {
      aVal = a.project.artifactId || '';
      bVal = b.project.artifactId || '';
    } else if (column === 'path') {
      aVal = a.project.path || '';
      bVal = b.project.path || '';
    } else {
      aVal = a.project[column] || '';
      bVal = b.project[column] || '';
    }

    if (typeof aVal === 'string') {
      aVal = aVal.toLowerCase();
      bVal = bVal.toLowerCase();
    }

    if (aVal < bVal) return currentSort.ascending ? -1 : 1;
    if (aVal > bVal) return currentSort.ascending ? 1 : -1;
    return 0;
  });

  renderProjectsTable();
}

// View vulnerabilities for a project
async function viewVulnerabilities(projectKey) {
  try {
    const response = await fetch(`/api/projects/${encodeURIComponent(projectKey)}/vulnerabilities`);
    const result = await response.json();

    if (result.success) {
      showVulnerabilityModal(projectKey, result.data);
    } else {
      alert(result.message || 'Failed to load vulnerabilities');
    }
  } catch (error) {
    console.error('Error loading vulnerabilities:', error);
    alert('Failed to load vulnerabilities');
  }
}

// Show vulnerability modal
function showVulnerabilityModal(projectKey, vulnerabilities) {
  const modal = document.getElementById('vulnerabilityModal');
  const modalTitle = document.getElementById('modalTitle');
  const modalBody = document.getElementById('modalBody');

  modalTitle.textContent = `Vulnerabilities - ${projectKey}`;

  if (vulnerabilities.length === 0) {
    modalBody.innerHTML = '<p style="text-align: center; padding: 2rem; color: var(--text-secondary);">No vulnerabilities found for this project.</p>';
  } else {
    const vulnHTML = vulnerabilities.map(vuln => `
      <div class="vuln-item">
        <div class="vuln-header">
          <div class="vuln-id">${escapeHtml(vuln.cveId)}</div>
          <span class="severity-badge ${vuln.cvss.severity.toLowerCase()}">
            ${vuln.cvss.severity}
          </span>
        </div>
        <div class="vuln-description">${escapeHtml(vuln.description)}</div>
        <div class="vuln-meta">
          <div class="meta-item">
            <span class="meta-label">CVSS Score</span>
            <span class="meta-value cvss-score" style="color: ${getSeverityColor(vuln.cvss.severity)}">
              ${vuln.cvss.score}
            </span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Dependency</span>
            <span class="meta-value">
              <code>${escapeHtml(vuln.dependency.groupId)}:${escapeHtml(vuln.dependency.artifactId)}:${escapeHtml(vuln.dependency.version)}</code>
            </span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Published</span>
            <span class="meta-value">${formatDate(vuln.published)}</span>
          </div>
          ${vuln.cwes && vuln.cwes.length > 0 ? `
            <div class="meta-item">
              <span class="meta-label">CWE</span>
              <span class="meta-value">${vuln.cwes.join(', ')}</span>
            </div>
          ` : ''}
        </div>
        ${vuln.references && vuln.references.length > 0 ? `
          <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border-color);">
            <span class="meta-label">References:</span>
            <ul style="margin-top: 0.5rem; padding-left: 1.5rem;">
              ${vuln.references.slice(0, 3).map(ref => `
                <li><a href="${escapeHtml(ref)}" target="_blank" style="color: #667eea; text-decoration: none;">${escapeHtml(ref)}</a></li>
              `).join('')}
            </ul>
          </div>
        ` : ''}
      </div>
    `).join('');

    modalBody.innerHTML = vulnHTML;
  }

  modal.classList.remove('hidden');
}

// Close modal
function closeModal() {
  document.getElementById('vulnerabilityModal').classList.add('hidden');
}

// Close modal when clicking outside
window.addEventListener('click', (e) => {
  const modal = document.getElementById('vulnerabilityModal');
  if (e.target === modal) {
    closeModal();
  }
});

// Utility functions
function showLoading(show) {
  const loading = document.getElementById('loading');
  if (show) {
    loading.classList.remove('hidden');
  } else {
    loading.classList.add('hidden');
  }
}

function showNoData(message) {
  document.getElementById('statsCards').innerHTML = '';
  document.getElementById('projectsTableBody').innerHTML =
    `<tr><td colspan="10" class="no-data">${escapeHtml(message)}</td></tr>`;
}

function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

function getSeverityColor(severity) {
  const colors = {
    CRITICAL: '#ff3b3b',
    HIGH: '#ff8c00',
    MEDIUM: '#ffd700',
    LOW: '#4a9eff'
  };
  return colors[severity.toUpperCase()] || '#a0a0a0';
}

function formatDate(dateString) {
  if (!dateString || dateString === 'Unknown') return 'Unknown';
  try {
    const date = new Date(dateString);
    return date.toLocaleDateString('ko-KR', { year: 'numeric', month: 'short', day: 'numeric' });
  } catch {
    return dateString;
  }
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', init);
