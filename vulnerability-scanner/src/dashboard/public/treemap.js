// Tree Map Visualization
document.addEventListener('DOMContentLoaded', init);

let allProjectsData = [];

async function init() {
    try {
        const response = await fetch('/api/results');
        const result = await response.json();

        if (result.success && result.data) {
            allProjectsData = result.data.projects;

            // Check for drill-down param
            const urlParams = new URLSearchParams(window.location.search);
            const projectKey = urlParams.get('project');

            if (projectKey) {
                renderProjectDetail(projectKey);
            } else {
                renderGlobalView();
            }
        } else {
            showError('No data available to render map.');
        }
    } catch (error) {
        console.error('Failed to load results:', error);
        showError('Failed to load data.');
    }
}

function showError(msg) {
    document.getElementById('treeMapChart').innerHTML =
        `<p style="text-align:center; padding: 2rem;">${msg}</p>`;
}

// ----------------------------------------------------------------------
// View 1: Global Project View
// ----------------------------------------------------------------------
function renderGlobalView() {
    // Breadcrumbs
    updateBreadcrumbs([{ text: 'All Projects', href: '#' }]);

    // Calculate specific risk score for each project
    const projectData = allProjectsData.map(p => {
        const s = p.summary;
        const riskScore = calculateRiskScore(s);

        return {
            x: p.project.name || p.project.artifactId || 'Unknown',
            y: riskScore,
            riskScore: riskScore,
            projectKey: p.project.key,
            totalCount: s.total || 0,
            critical: s.critical || 0,
            high: s.high || 0
        };
    }).filter(item => item.y > 0);

    // Sort by risk score desc
    projectData.sort((a, b) => b.y - a.y);
    const totalSystemRisk = projectData.reduce((acc, curr) => acc + curr.y, 0);

    const options = {
        series: [{
            data: projectData.map(item => ({
                x: item.x,
                y: item.y,
                fillColor: getRiskColor(item.riskScore)
            }))
        }],
        chart: {
            height: '100%',
            type: 'treemap',
            fontFamily: 'Inter, sans-serif',
            toolbar: { show: false },
            events: {
                dataPointSelection: function (event, chartContext, config) {
                    const dataPointIndex = config.dataPointIndex;
                    const selectedProject = projectData[dataPointIndex];
                    if (selectedProject) {
                        window.location.href = `?project=${encodeURIComponent(selectedProject.projectKey)}`;
                    }
                }
            }
        },
        title: {
            text: 'Global Risk Map (Click to Drill-down)',
            align: 'center',
            style: { color: '#fff' }
        },
        colors: ['#FF3B3B', '#FF8C00', '#FFD700', '#4A9EFF'],
        plotOptions: {
            treemap: {
                distributed: true,
                enableShades: false,
                shadeIntensity: 0.5,
            }
        },
        dataLabels: {
            enabled: true,
            style: { fontSize: '14px', fontWeight: 'bold', colors: ['#ffffff'] },
            formatter: function (text, op) {
                const val = op.value;
                const percent = totalSystemRisk > 0 ? ((val / totalSystemRisk) * 100).toFixed(1) : 0;
                return [text, `${percent}%`];
            },
            offsetY: -4
        },
        tooltip: {
            theme: 'dark',
            y: {
                formatter: function (value, { dataPointIndex }) {
                    const data = projectData[dataPointIndex];
                    return `
                        <div>Risk Score: <b>${value}</b></div>
                        <div>Total Vulns: ${data.totalCount}</div>
                        <div style="margin-top:4px; font-size:0.85em; color: #ff3b3b">Critical: ${data.critical}</div>
                        <div style="font-size:0.85em; color: #ff8c00">High: ${data.high}</div>
                        <div style="margin-top:6px; font-size:0.8em; color: #aaa;">Click to view details</div>
                    `;
                }
            }
        }
    };

    renderChart(options);
}

// ----------------------------------------------------------------------
// View 2: Project Detail View (Dependencies)
// ----------------------------------------------------------------------
function renderProjectDetail(projectKey) {
    const project = allProjectsData.find(p => p.project.key === projectKey);

    if (!project) {
        showError(`Project not found: ${projectKey}`);
        return;
    }

    // Breadcrumbs
    updateBreadcrumbs([
        { text: 'All Projects', href: 'treemap.html' },
        { text: project.project.name, href: '#' }
    ]);

    // Aggregate by Dependency
    const dependencyMap = new Map();

    project.vulnerabilities.forEach(v => {
        const depKey = `${v.dependency.groupId}:${v.dependency.artifactId}`;

        if (!dependencyMap.has(depKey)) {
            dependencyMap.set(depKey, {
                name: v.dependency.artifactId,
                groupId: v.dependency.groupId,
                version: v.dependency.version,
                vulnerabilities: []
            });
        }
        dependencyMap.get(depKey).vulnerabilities.push(v);
    });

    const depData = Array.from(dependencyMap.values()).map(dep => {
        // Calculate risk for this specific dependency
        const summary = { critical: 0, high: 0, medium: 0, low: 0 };
        dep.vulnerabilities.forEach(v => {
            const sev = v.cvss.severity.toLowerCase();
            if (summary[sev] !== undefined) summary[sev]++;
        });

        const riskScore = calculateRiskScore(summary);

        return {
            x: `${dep.name} (${dep.version})`,
            y: riskScore,
            riskScore: riskScore,
            summary: summary,
            vulnCount: dep.vulnerabilities.length,
            topCve: dep.vulnerabilities[0]?.cveId // Just for info
        };
    }).filter(d => d.y > 0);

    depData.sort((a, b) => b.y - a.y);
    const totalProjectRisk = depData.reduce((acc, curr) => acc + curr.y, 0);

    const options = {
        series: [{
            data: depData.map(item => ({
                x: item.x,
                y: item.y,
                fillColor: getRiskColor(item.riskScore)
            }))
        }],
        chart: {
            height: '100%',
            type: 'treemap',
            fontFamily: 'Inter, sans-serif',
            toolbar: { show: false }
        },
        title: {
            text: `Risk Breakdown: ${project.project.name}`,
            align: 'center',
            style: { color: '#fff' }
        },
        colors: ['#FF3B3B', '#FF8C00', '#FFD700', '#4A9EFF'],
        plotOptions: {
            treemap: {
                distributed: true,
                enableShades: false,
                shadeIntensity: 0.5,
            }
        },
        dataLabels: {
            enabled: true,
            style: { fontSize: '14px', fontWeight: 'bold', colors: ['#ffffff'] },
            formatter: function (text, op) {
                const val = op.value;
                const percent = totalProjectRisk > 0 ? ((val / totalProjectRisk) * 100).toFixed(1) : 0;
                return [text, `${percent}%`];
            },
            offsetY: -4
        },
        tooltip: {
            theme: 'dark',
            y: {
                formatter: function (value, { dataPointIndex }) {
                    const data = depData[dataPointIndex];
                    return `
                        <div>Risk Score: <b>${value}</b></div>
                        <div>Vulns: ${data.vulnCount}</div>
                        <div style="margin-top:4px; font-size:0.85em; color: #ff3b3b">Critical: ${data.summary.critical}</div>
                        <div style="font-size:0.85em; color: #ff8c00">High: ${data.summary.high}</div>
                    `;
                }
            }
        }
    };

    renderChart(options);
}

// ----------------------------------------------------------------------
// Helpers
// ----------------------------------------------------------------------
function renderChart(options) {
    document.getElementById('treeMapChart').innerHTML = ''; // Clear previous
    const chart = new ApexCharts(document.querySelector("#treeMapChart"), options);
    chart.render();
}

function calculateRiskScore(summary) {
    return (summary.critical || 0) * 10 +
        (summary.high || 0) * 5 +
        (summary.medium || 0) * 2 +
        (summary.low || 0) * 1;
}

function getRiskColor(score) {
    if (score >= 100) return '#8B0000'; // Dark Red
    if (score >= 50) return '#FF3B3B'; // Red
    if (score >= 20) return '#FF8C00'; // Orange
    if (score >= 5) return '#FFD700'; // Yellow
    return '#4A9EFF'; // Blue
}

function updateBreadcrumbs(items) {
    // Create breadcrumb container if not exists (it should, but just in case of simple HTML update)
    let container = document.getElementById('breadcrumbs');
    if (!container) {
        // If it doesn't exist in HTML, we might need to inject it or ignore. 
        // For now, let's assume I'll add it to HTML or inject it before chart.
        const chartContainer = document.querySelector('.chart-container');
        if (chartContainer) {
            container = document.createElement('div');
            container.id = 'breadcrumbs';
            container.className = 'breadcrumbs';
            container.style.padding = '0 1rem';
            chartContainer.parentNode.insertBefore(container, chartContainer);
        }
    }

    if (container) {
        container.innerHTML = items.map((item, index) => {
            if (index === items.length - 1) {
                return `<span>${item.text}</span>`;
            }
            return `<a href="${item.href}">${item.text}</a> <span>/</span>`;
        }).join(' ');
    }
}
