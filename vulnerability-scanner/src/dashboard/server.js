import express from 'express';
import path from 'path';
import { fileURLToPath } from 'url';
import { Scanner } from '../../bin/scanner.js';
import { config } from '../core/config.js';
import fs from 'fs/promises';
import { cveDb } from '../service/cve-service.js';
import ExcelJS from 'exceljs';

// Initialize CVE Database
await cveDb.init();

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
const PORT = config.dashboardPort;

// Parse CLI arguments for Scanner
const args = process.argv.slice(2);
const scannerOptions = {};

for (let i = 0; i < args.length; i++) {
    if (args[i] === '--cves' && args[i + 1]) {
        scannerOptions.cveBasePath = args[i + 1];
        i++;
    } else if (args[i] === '--target' && args[i + 1]) {
        scannerOptions.projectScanPath = args[i + 1];
        i++;
    }
}

if (scannerOptions.cveBasePath) console.log(`üîß Dashboard: Using Custom CVE Path: ${scannerOptions.cveBasePath}`);
if (scannerOptions.projectScanPath) console.log(`üîß Dashboard: Using Custom Target Path: ${scannerOptions.projectScanPath}`);

// Middleware
app.use(express.json());
app.use(express.static(path.join(__dirname, 'public')));

// Ensure output directory exists for scans
const ensureOutputDir = async () => {
    try {
        await fs.mkdir(config.outputDir, { recursive: true });
    } catch (err) {
        console.error(`‚ùå Failed to create output directory: ${err.message}`);
    }
};
ensureOutputDir();

// Global scanner instance
let latestResults = null;
let isScanning = false;

/**
 * API: Get latest scan results
 */
app.get('/api/results', async (req, res) => {
    try {
        // Try to load from file if not in memory
        if (!latestResults) {
            const outputPath = path.join(config.outputDir, config.outputFileName);
            try {
                const data = await fs.readFile(outputPath, 'utf8');
                latestResults = JSON.parse(data);
            } catch (error) {
                return res.json({
                    success: false,
                    message: 'No scan results available. Please run a scan first.'
                });
            }
        }

        res.json({ success: true, data: latestResults });
    } catch (error) {
        res.status(500).json({ success: false, error: error.message });
    }
});

/**
 * API: Trigger new scan
 */
app.post('/api/scan', async (req, res) => {
    if (isScanning) {
        return res.json({
            success: false,
            message: 'A scan is already in progress'
        });
    }

    try {
        isScanning = true;
        res.json({ success: true, message: 'Scan started' });

        // Run scan asynchronously
        const scanner = new Scanner(scannerOptions);
        latestResults = await scanner.scan();
        isScanning = false;
    } catch (error) {
        isScanning = false;
        console.error('Scan error:', error);
    }
});

/**
 * API: Get scan status
 */
app.get('/api/status', (req, res) => {
    res.json({
        isScanning,
        hasResults: latestResults !== null
    });
});

/**
 * API: Get list of projects
 */
app.get('/api/projects', (req, res) => {
    if (!latestResults) {
        return res.json({ success: false, message: 'No scan results available' });
    }

    const projects = latestResults.projects.map(p => ({
        name: p.project.name,
        key: p.project.key,
        type: p.project.type,
        javaVersion: p.project.javaVersion,
        vulnerabilityCount: p.vulnerabilities.length,
        summary: p.summary
    }));

    res.json({ success: true, data: projects });
});

/**
 * API: Get vulnerabilities for a specific project
 */
app.get('/api/projects/:projectKey/vulnerabilities', (req, res) => {
    if (!latestResults) {
        return res.json({ success: false, message: 'No scan results available' });
    }

    const projectKey = decodeURIComponent(req.params.projectKey);
    const project = latestResults.projects.find(p => p.project.key === projectKey);

    if (!project) {
        return res.status(404).json({ success: false, message: 'Project not found' });
    }

    res.json({ success: true, data: project.vulnerabilities });
});

/**
 * API: Get all CVEs (limited) or search CVEs
 */
app.get('/api/cves', async (req, res) => {
    try {
        const page = parseInt(req.query.page) || 1;
        const pageSize = parseInt(req.query.pageSize) || 50;
        const result = await cveDb.searchByProduct('', page, pageSize);
        res.json(result);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

app.get('/api/cves/search', async (req, res) => {
    try {
        const product = req.query.product || '';
        const page = parseInt(req.query.page) || 1;
        const pageSize = parseInt(req.query.pageSize) || 50;
        const result = await cveDb.searchByProduct(product, page, pageSize);
        res.json(result);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

/**
 * API: Export CVEs to Excel
 */
app.get('/api/cves/export', async (req, res) => {
    try {
        const product = req.query.product || '';
        // Export might want full list or current filter results. 
        // User requested "ÌéòÏù¥ÏßïÎã®ÏúÑÎ°ú" (by page unit), but usually export is for all filtered results.
        // Let's implement it for the current page and size if provided, otherwise all filtered results (with a reasonable limit).
        const page = parseInt(req.query.page) || 1;
        const pageSize = parseInt(req.query.pageSize) || 100; // Default export limit if not specified

        const { rows } = await cveDb.searchByProduct(product, page, pageSize);

        const workbook = new ExcelJS.Workbook();
        const worksheet = workbook.addWorksheet('CVEs');

        worksheet.columns = [
            { header: 'CVE ID', key: 'cveId', width: 20 },
            { header: 'Severity', key: 'severity', width: 15 },
            { header: 'Score', key: 'cvssScore', width: 10 },
            { header: 'Product', key: 'product', width: 25 },
            { header: 'Vendor', key: 'vendor', width: 25 },
            { header: 'Published', key: 'datePublished', width: 20 },
            { header: 'Description', key: 'description', width: 50 }
        ];

        rows.forEach(row => {
            worksheet.addRow({
                ...row,
                datePublished: row.datePublished ? row.datePublished.split('T')[0] : ''
            });
        });

        // Styling
        worksheet.getRow(1).font = { bold: true };
        worksheet.getRow(1).fill = {
            type: 'pattern',
            pattern: 'solid',
            fgColor: { argb: 'FFE0E0E0' }
        };

        res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
        res.setHeader('Content-Disposition', `attachment; filename=CVE_Export_${new Date().toISOString().split('T')[0]}.xlsx`);

        await workbook.xlsx.write(res);
        res.end();
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

/**
 * API: Get available filter options for visualization
 */
app.get('/api/cves/visual/filters', async (req, res) => {
    try {
        const filters = await cveDb.getFilterOptions();
        res.json({ success: true, data: filters });
    } catch (error) {
        res.status(500).json({ success: false, error: error.message });
    }
});

/**
 * API: Get Year/Score distribution for visualization
 */
app.get('/api/cves/visual/year-score', async (req, res) => {
    try {
        const years = req.query.years ? req.query.years.split(',') : [];
        const products = req.query.products ? req.query.products.split(',') : [];
        const data = await cveDb.getYearScoreDistribution({ years, products });
        res.json({ success: true, data });
    } catch (error) {
        res.status(500).json({ success: false, error: error.message });
    }
});

/**
 * API: Get Yearly/Severity distribution (for stacked bar chart)
 */
app.get('/api/cves/visual/yearly-severity', async (req, res) => {
    try {
        const data = await cveDb.getYearlySeverityDistribution();
        res.json({ success: true, data });
    } catch (error) {
        res.status(500).json({ success: false, error: error.message });
    }
});

/**
 * API: Get detailed CVE list filtered by year and severity
 */
app.get('/api/cves/visual/severity-list', async (req, res) => {
    try {
        const { year, severity } = req.query;
        const limit = parseInt(req.query.limit) || 50;
        const data = await cveDb.getCvesByFilter({ year, severity }, limit);
        res.json({ success: true, data });
    } catch (error) {
        res.status(500).json({ success: false, error: error.message });
    }
});

/**
 * API: Get Product distribution for visualization
 */
app.get('/api/cves/visual/product', async (req, res) => {
    try {
        const limit = parseInt(req.query.limit) || 20;
        const years = req.query.years ? req.query.years.split(',') : [];
        const data = await cveDb.getProductDistribution(limit, { years });
        res.json({ success: true, data });
    } catch (error) {
        res.status(500).json({ success: false, error: error.message });
    }
});

/**
 * Serve dashboard HTML
 */
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

/**
 * Catch-all route for unknown pages - Serve 404.html
 */
app.get('*', (req, res) => {
    res.status(404).sendFile(path.join(__dirname, 'public', '404.html'));
});

/**
 * Start server
 */
const server = app.listen(PORT, () => {
    console.log(`üöÄ Dashboard server running at http://localhost:${PORT}`);
    console.log(`üìä Open your browser to view the vulnerability dashboard`);
});

server.on('error', (e) => {
    if (e.code === 'EADDRINUSE') {
        console.error(`\n‚ùå Error: Port ${PORT} is already in use.`);
        console.error(`üí° Tip: Another dashboard might be running. Please close it first or change 'dashboardPort' in 'src/core/config.js'.\n`);
        process.exit(1);
    } else {
        console.error(`‚ùå Server error: ${e.message}`);
    }
});
