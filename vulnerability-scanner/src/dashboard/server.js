import express from 'express';
import path from 'path';
import { fileURLToPath } from 'url';
import { Scanner } from '../../bin/scanner.js';
import { config } from '../core/config.js';
import fs from 'fs/promises';
import { cveDb } from '../service/cve-service.js';
import { GitService } from '../service/git-service.js';
import { SyncGitProjectsUseCase } from '../application/git/sync-projects-use-case.js';
import ExcelJS from 'exceljs';

// Initialize CVE Database in background
cveDb.init().catch(err => {
    console.error(`‚ùå Dashboard: Database initialization failed: ${err.message}`);
});

// SSL Bypass for Internal APIs (equivalent to curl -k)
if (config.gitRejectUnauthorized === false) {
    process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';
    console.log('üîì SSL: Certificate validation disabled (Insecure mode)');
}

const gitService = new GitService();
const syncUseCase = new SyncGitProjectsUseCase(gitService, cveDb.gitRepos);

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
const PORT = config.dashboardPort;

// Parse CLI arguments for Scanner
const args = process.argv.slice(2);
const scannerOptions = {};

for (let i = 0; i < args.length; i++) {
    if (args[i] === '--cves' && args[i + 1]) {
        scannerOptions.cveBasePath = args[i + 1];
        i++;
    } else if (args[i] === '--target' && args[i + 1]) {
        scannerOptions.projectScanPath = args[i + 1];
        i++;
    }
}

if (scannerOptions.cveBasePath) console.log(`üîß Dashboard: Using Custom CVE Path: ${scannerOptions.cveBasePath}`);
if (scannerOptions.projectScanPath) console.log(`üîß Dashboard: Using Custom Target Path: ${scannerOptions.projectScanPath}`);

// Middleware
app.use(express.json());
app.use(express.static(path.join(__dirname, 'public')));

// Ensure output directory exists for scans
const ensureOutputDir = async () => {
    try {
        await fs.mkdir(config.outputDir, { recursive: true });
    } catch (err) {
        console.error(`‚ùå Failed to create output directory: ${err.message}`);
    }
};
ensureOutputDir();

// Global scanner instance
let latestResults = null;
let isScanning = false;

/**
 * API: Get latest scan results
 */
app.get('/api/results', async (req, res) => {
    try {
        // Try to load from file if not in memory
        if (!latestResults) {
            const outputPath = path.join(config.outputDir, config.outputFileName);
            try {
                const data = await fs.readFile(outputPath, 'utf8');
                latestResults = JSON.parse(data);
            } catch (error) {
                return res.json({
                    success: false,
                    message: 'No scan results available. Please run a scan first.'
                });
            }
        }

        res.json({ success: true, data: latestResults });
    } catch (error) {
        res.status(500).json({ success: false, error: error.message });
    }
});

/**
 * API: Trigger new scan
 */
app.post('/api/scan', async (req, res) => {
    if (isScanning) {
        return res.json({
            success: false,
            message: 'A scan is already in progress'
        });
    }

    try {
        isScanning = true;
        res.json({ success: true, message: 'Scan started' });

        // Run scan asynchronously
        const scanner = new Scanner({
            ...scannerOptions,
            db: cveDb
        });
        latestResults = await scanner.scan();
        isScanning = false;
    } catch (error) {
        isScanning = false;
        console.error('Scan error:', error);
    }
});

// ----------------------------------------------------------------------
// Git Project Sync & Dashboard APIs
// ----------------------------------------------------------------------

/**
 * API: Get paginated Git projects from local DB
 */
app.get('/api/git/projects', async (req, res) => {
    try {
        const page = parseInt(req.query.page) || 1;
        const pageSize = parseInt(req.query.pageSize) || 25;
        const result = await cveDb.gitRepos.getProjects(page, pageSize);
        res.json({ success: true, ...result });
    } catch (error) {
        res.status(500).json({ success: false, error: error.message });
    }
});

/**
 * API: Sync projects from remote Git API to local DB (CQRS/DDD Implementation)
 */
app.post('/api/git/sync', async (req, res) => {
    try {
        const result = await syncUseCase.execute();
        res.json({
            success: true,
            count: result.totalProjectsSynced,
            repoCount: result.totalReposSynced
        });
    } catch (error) {
        console.error('‚ùå Git sync error:', error);
        res.status(500).json({ success: false, error: error.message });
    }
});

/**
 * API: Get repositories for a project
 */
app.get('/api/git/repos', async (req, res) => {
    try {
        const { projectKey } = req.query;
        if (!projectKey) {
            return res.status(400).json({ success: false, error: 'projectKey is required' });
        }
        const repos = await cveDb.gitRepos.getRepos(projectKey);
        res.json({ success: true, rows: repos });
    } catch (error) {
        res.status(500).json({ success: false, error: error.message });
    }
});

/**
 * API: Export Git projects to Excel
 */
app.get('/api/git/export', async (req, res) => {
    try {
        const result = await cveDb.gitRepos.getProjects(1, 10000); // Fetch all for export
        const projects = result.rows;

        const workbook = new ExcelJS.Workbook();
        const sheet = workbook.addWorksheet('Git Projects');

        sheet.columns = [
            { header: 'No', key: 'no', width: 10 },
            { header: 'Project Name', key: 'name', width: 30 },
            { header: 'Project Key', key: 'key', width: 20 },
            { header: 'Description', key: 'description', width: 50 },
            { header: 'Last Synced', key: 'lastSynced', width: 25 }
        ];

        projects.forEach((p, idx) => {
            sheet.addRow({
                no: idx + 1,
                name: p.name,
                key: p.key,
                description: p.description,
                lastSynced: p.lastSynced
            });
        });

        // Styling
        sheet.getRow(1).font = { bold: true };
        sheet.getRow(1).fill = {
            type: 'pattern',
            pattern: 'solid',
            fgColor: { argb: 'FFE0E0E0' }
        };

        res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
        res.setHeader('Content-Disposition', 'attachment; filename=gitprojects.xlsx');

        await workbook.xlsx.write(res);
        res.end();
    } catch (error) {
        res.status(500).json({ success: false, error: error.message });
    }
});

/**
 * API: Get scan status
 */
app.get('/api/status', (req, res) => {
    res.json({
        isScanning,
        hasResults: latestResults !== null
    });
});

/**
 * API: Get list of projects
 */
app.get('/api/projects', (req, res) => {
    if (!latestResults) {
        return res.json({ success: false, message: 'No scan results available' });
    }

    const projects = latestResults.projects.map(p => ({
        name: p.project.name,
        key: p.project.key,
        type: p.project.type,
        javaVersion: p.project.javaVersion,
        vulnerabilityCount: p.vulnerabilities.length,
        summary: p.summary
    }));

    res.json({ success: true, data: projects });
});

/**
 * API: Get vulnerabilities for a specific project
 */
app.get('/api/projects/:projectKey/vulnerabilities', (req, res) => {
    if (!latestResults) {
        return res.json({ success: false, message: 'No scan results available' });
    }

    const projectKey = decodeURIComponent(req.params.projectKey);
    const project = latestResults.projects.find(p => p.project.key === projectKey);

    if (!project) {
        return res.status(404).json({ success: false, message: 'Project not found' });
    }

    res.json({ success: true, data: project.vulnerabilities });
});

/**
 * API: Get all CVEs (limited) or search CVEs
 */
app.get('/api/cves', async (req, res) => {
    if (!cveDb.initialized) {
        return res.status(503).json({ success: false, loading: true, message: 'CVE Database is still loading...' });
    }
    try {
        const page = parseInt(req.query.page) || 1;
        const pageSize = parseInt(req.query.pageSize) || 50;
        const filters = {
            product: req.query.product || '',
            cveId: req.query.cveId || ''
        };
        const result = await cveDb.searchByFilters(filters, page, pageSize);
        res.json(result);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

app.get('/api/cves/search', async (req, res) => {
    if (!cveDb.initialized) {
        return res.status(503).json({ success: false, loading: true, message: 'CVE Database is still loading...' });
    }
    try {
        const page = parseInt(req.query.page) || 1;
        const pageSize = parseInt(req.query.pageSize) || 50;
        const filters = {
            product: req.query.product || '',
            cveId: req.query.cveId || ''
        };
        const result = await cveDb.searchByFilters(filters, page, pageSize);
        res.json(result);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

/**
 * API: Export CVEs to Excel
 */
app.get('/api/cves/export', async (req, res) => {
    if (!cveDb.initialized) {
        return res.status(503).json({ success: false, loading: true, message: 'CVE Database is still loading...' });
    }
    try {
        const filters = {
            product: req.query.product || '',
            cveId: req.query.cveId || ''
        };
        const page = parseInt(req.query.page) || 1;
        const pageSize = parseInt(req.query.pageSize) || 100;

        const { rows } = await cveDb.searchByFilters(filters, page, pageSize);

        const workbook = new ExcelJS.Workbook();
        const worksheet = workbook.addWorksheet('CVEs');

        worksheet.columns = [
            { header: 'CVE ID', key: 'cveId', width: 20 },
            { header: 'Severity', key: 'severity', width: 15 },
            { header: 'Score', key: 'cvssScore', width: 10 },
            { header: 'Product', key: 'product', width: 25 },
            { header: 'Vendor', key: 'vendor', width: 25 },
            { header: 'Published', key: 'datePublished', width: 20 },
            { header: 'Description', key: 'description', width: 50 }
        ];

        rows.forEach(row => {
            worksheet.addRow({
                ...row,
                datePublished: row.datePublished ? row.datePublished.split('T')[0] : ''
            });
        });

        // Styling
        worksheet.getRow(1).font = { bold: true };
        worksheet.getRow(1).fill = {
            type: 'pattern',
            pattern: 'solid',
            fgColor: { argb: 'FFE0E0E0' }
        };

        res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
        res.setHeader('Content-Disposition', `attachment; filename=CVE_Export_${new Date().toISOString().split('T')[0]}.xlsx`);

        await workbook.xlsx.write(res);
        res.end();
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

/**
 * API: Get available filter options for visualization
 */
app.get('/api/cves/visual/filters', async (req, res) => {
    try {
        const filters = await cveDb.getFilterOptions();
        res.json({ success: true, data: filters });
    } catch (error) {
        res.status(500).json({ success: false, error: error.message });
    }
});

/**
 * API: Get Year/Score distribution for visualization
 */
app.get('/api/cves/visual/year-score', async (req, res) => {
    try {
        const years = req.query.years ? req.query.years.split(',') : [];
        const products = req.query.products ? req.query.products.split(',') : [];
        const data = await cveDb.getYearScoreDistribution({ years, products });
        res.json({ success: true, data });
    } catch (error) {
        res.status(500).json({ success: false, error: error.message });
    }
});

/**
 * API: Get Yearly/Severity distribution (for stacked bar chart)
 */
app.get('/api/cves/visual/yearly-severity', async (req, res) => {
    try {
        const data = await cveDb.getYearlySeverityDistribution();
        res.json({ success: true, data });
    } catch (error) {
        res.status(500).json({ success: false, error: error.message });
    }
});

/**
 * API: Get detailed CVE list filtered by year and severity
 */
app.get('/api/cves/visual/severity-list', async (req, res) => {
    try {
        const { year, severity } = req.query;
        const limit = parseInt(req.query.limit) || 50;
        const data = await cveDb.getCvesByFilter({ year, severity }, limit);
        res.json({ success: true, data });
    } catch (error) {
        res.status(500).json({ success: false, error: error.message });
    }
});

/**
 * API: Get Product distribution for visualization
 */
app.get('/api/cves/visual/product', async (req, res) => {
    try {
        const limit = parseInt(req.query.limit) || 20;
        const years = req.query.years ? req.query.years.split(',') : [];
        const data = await cveDb.getProductDistribution(limit, { years });
        res.json({ success: true, data });
    } catch (error) {
        res.status(500).json({ success: false, error: error.message });
    }
});

/**
 * API: Chatbot - Send message to vLLM
 */
app.post('/api/chatbot/send', async (req, res) => {
    try {
        const { message, history } = req.body;

        if (!message) {
            return res.status(400).json({ success: false, error: 'Message is required' });
        }

        // Call vLLM API
        const response = await fetch(`${config.vllmApiUrl}/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                model: config.vllmModel,
                messages: [
                    { role: 'system', content: 'You are a helpful AI assistant.' },
                    ...(history || []),
                    { role: 'user', content: message }
                ],
                temperature: 0.7,
                max_tokens: 500
            })
        });

        if (!response.ok) {
            throw new Error(`vLLM API error: ${response.status}`);
        }

        const data = await response.json();
        const aiResponse = data.choices?.[0]?.message?.content || 'No response';

        res.json({ success: true, response: aiResponse });
    } catch (error) {
        console.error('Chatbot error:', error);
        res.status(500).json({ success: false, error: error.message });
    }
});

/**
 * Serve dashboard HTML
 */
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

/**
 * Catch-all route for unknown pages - Serve 404.html
 */
app.get('*', (req, res) => {
    res.status(404).sendFile(path.join(__dirname, 'public', '404.html'));
});

/**
 * Start server
 */
const server = app.listen(PORT, () => {
    console.log(`üöÄ Dashboard server running at http://localhost:${PORT}`);
    console.log(`üìä Open your browser to view the vulnerability dashboard`);
});

server.on('error', (e) => {
    if (e.code === 'EADDRINUSE') {
        console.error(`\n‚ùå Error: Port ${PORT} is already in use.`);
        console.error(`üí° Tip: Another dashboard might be running. Please close it first or change 'dashboardPort' in 'src/core/config.js'.\n`);
        process.exit(1);
    } else {
        console.error(`‚ùå Server error: ${e.message}`);
    }
});
