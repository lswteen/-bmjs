import express from 'express';
import path from 'path';
import { fileURLToPath } from 'url';
import { Scanner } from '../scanner.js';
import { config } from '../config.js';
import fs from 'fs/promises';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
const PORT = config.dashboardPort;

// Middleware
app.use(express.json());
app.use(express.static(path.join(__dirname, 'public')));

// Global scanner instance
let latestResults = null;
let isScanning = false;

/**
 * API: Get latest scan results
 */
app.get('/api/results', async (req, res) => {
    try {
        // Try to load from file if not in memory
        if (!latestResults) {
            const outputPath = path.join(config.outputDir, config.outputFileName);
            try {
                const data = await fs.readFile(outputPath, 'utf8');
                latestResults = JSON.parse(data);
            } catch (error) {
                return res.json({
                    success: false,
                    message: 'No scan results available. Please run a scan first.'
                });
            }
        }

        res.json({ success: true, data: latestResults });
    } catch (error) {
        res.status(500).json({ success: false, error: error.message });
    }
});

/**
 * API: Trigger new scan
 */
app.post('/api/scan', async (req, res) => {
    if (isScanning) {
        return res.json({
            success: false,
            message: 'A scan is already in progress'
        });
    }

    try {
        isScanning = true;
        res.json({ success: true, message: 'Scan started' });

        // Run scan asynchronously
        const scanner = new Scanner();
        latestResults = await scanner.scan();
        isScanning = false;
    } catch (error) {
        isScanning = false;
        console.error('Scan error:', error);
    }
});

/**
 * API: Get scan status
 */
app.get('/api/status', (req, res) => {
    res.json({
        isScanning,
        hasResults: latestResults !== null
    });
});

/**
 * API: Get list of projects
 */
app.get('/api/projects', (req, res) => {
    if (!latestResults) {
        return res.json({ success: false, message: 'No scan results available' });
    }

    const projects = latestResults.projects.map(p => ({
        name: p.project.name,
        key: p.project.key,
        type: p.project.type,
        javaVersion: p.project.javaVersion,
        vulnerabilityCount: p.vulnerabilities.length,
        summary: p.summary
    }));

    res.json({ success: true, data: projects });
});

/**
 * API: Get vulnerabilities for a specific project
 */
app.get('/api/projects/:projectKey/vulnerabilities', (req, res) => {
    if (!latestResults) {
        return res.json({ success: false, message: 'No scan results available' });
    }

    const projectKey = decodeURIComponent(req.params.projectKey);
    const project = latestResults.projects.find(p => p.project.key === projectKey);

    if (!project) {
        return res.status(404).json({ success: false, message: 'Project not found' });
    }

    res.json({ success: true, data: project.vulnerabilities });
});

/**
 * Serve dashboard HTML
 */
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

/**
 * Start server
 */
app.listen(PORT, () => {
    console.log(`ðŸš€ Dashboard server running at http://localhost:${PORT}`);
    console.log(`ðŸ“Š Open your browser to view the vulnerability dashboard`);
});
