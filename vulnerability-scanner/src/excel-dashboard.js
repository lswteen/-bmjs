import ExcelJS from 'exceljs';
import fs from 'fs/promises';
import path from 'path';
import { config } from './config.js';

/**
 * Generate Excel dashboard from scan results
 */
export class ExcelDashboard {
    constructor(results) {
        this.results = results;
        this.workbook = new ExcelJS.Workbook();
    }

    /**
     * Generate complete Excel dashboard
     */
    async generate(outputPath = null) {
        if (!outputPath) {
            await fs.mkdir(config.outputDir, { recursive: true });
            outputPath = path.join(config.outputDir, 'vulnerability-dashboard.xlsx');
        }

        // Create worksheets
        console.log('  ðŸ“Š Generating Summary Sheet...');
        try { this.createSummarySheet(); } catch (e) { console.error('  âŒ Failed Summary Sheet:', e); }

        console.log('  ðŸ“Š Generating Projects Sheet...');
        try { this.createProjectsSheet(); } catch (e) { console.error('  âŒ Failed Projects Sheet:', e); }

        console.log('  ðŸ“Š Generating Vulnerabilities Sheet...');
        try { this.createVulnerabilitiesSheet(); } catch (e) { console.error('  âŒ Failed Vulnerabilities Sheet:', e); }

        console.log('  ðŸ“Š Generating CVE Details Sheet...');
        try { this.createCVEDetailsSheet(); } catch (e) { console.error('  âŒ Failed CVE Details Sheet:', e); }

        // Save workbook
        console.log('  ðŸ’¾ Saving workbook...');
        await this.workbook.xlsx.writeFile(outputPath);
        console.log(`ðŸ“Š Excel dashboard saved to: ${outputPath}`);

        return outputPath;
    }

    /**
     * Create summary sheet with statistics
     */
    createSummarySheet() {
        const sheet = this.workbook.addWorksheet('Summary', {
            properties: { tabColor: { argb: 'FF667eea' } }
        });

        const stats = this.results.statistics;

        // Title
        sheet.mergeCells('A1:D1');
        sheet.getCell('A1').value = 'ðŸ›¡ï¸ Vulnerability Scan Summary';
        sheet.getCell('A1').font = { size: 18, bold: true, color: { argb: 'FF667eea' } };
        sheet.getCell('A1').alignment = { horizontal: 'center', vertical: 'middle' };
        sheet.getRow(1).height = 30;

        // Metadata
        sheet.getCell('A3').value = 'Scan Date:';
        sheet.getCell('B3').value = new Date(this.results.metadata.scanDate).toLocaleString('ko-KR');
        sheet.getCell('A4').value = 'Scanner Version:';
        sheet.getCell('B4').value = this.results.metadata.version;

        // Project Statistics
        sheet.getCell('A6').value = 'ðŸ“¦ Project Statistics';
        sheet.getCell('A6').font = { size: 14, bold: true };

        const projectStats = [
            ['Total Projects:', stats.projects.totalProjects],
            ['Maven Projects:', stats.projects.byType.maven],
            ['Gradle Projects:', stats.projects.byType.gradle],
            ['Total Dependencies:', stats.projects.totalDependencies]
        ];

        let row = 7;
        projectStats.forEach(([label, value]) => {
            sheet.getCell(`A${row}`).value = label;
            sheet.getCell(`B${row}`).value = value;
            sheet.getCell(`B${row}`).font = { bold: true };
            row++;
        });

        // Vulnerability Statistics
        sheet.getCell('A12').value = 'âš ï¸ Vulnerability Statistics';
        sheet.getCell('A12').font = { size: 14, bold: true };

        const vulnStats = stats.vulnerabilities;
        const vulnData = [
            ['Total Vulnerabilities:', vulnStats.totalVulnerabilities, null],
            ['Affected Projects:', vulnStats.projectsWithVulnerabilities, null],
            ['Unique CVEs:', vulnStats.uniqueCVEs, null],
            ['', '', ''],
            ['ðŸ”´ Critical:', vulnStats.bySeverity.critical, 'FFFF3B3B'],
            ['ðŸŸ  High:', vulnStats.bySeverity.high, 'FFFF8C00'],
            ['ðŸŸ¡ Medium:', vulnStats.bySeverity.medium, 'FFFFD700'],
            ['ðŸ”µ Low:', vulnStats.bySeverity.low, 'FF4A9EFF']
        ];

        row = 13;
        vulnData.forEach(([label, value, color]) => {
            sheet.getCell(`A${row}`).value = label;
            sheet.getCell(`B${row}`).value = value;
            sheet.getCell(`B${row}`).font = { bold: true };
            if (color) {
                sheet.getCell(`B${row}`).font = { bold: true, color: { argb: color } };
            }
            row++;
        });

        // Format columns
        sheet.getColumn('A').width = 30;
        sheet.getColumn('B').width = 20;
    }

    /**
   * Create projects overview sheet
   */
    createProjectsSheet() {
        const sheet = this.workbook.addWorksheet('Projects', {
            properties: { tabColor: { argb: 'FF4FACFE' } }
        });

        // Headers - ìƒˆë¡œìš´ êµ¬ì¡°
        const headers = [
            'Project Path',
            'Project Name',
            'Artifact ID',
            'Java Version',
            'Direct Deps',
            'Transitive Deps',
            'ðŸ”´ Critical',
            'ðŸŸ  High',
            'ðŸŸ¡ Medium',
            'ðŸ”µ Low'
        ];

        sheet.addRow(headers);

        // Style header row
        const headerRow = sheet.getRow(1);
        headerRow.font = { bold: true, color: { argb: 'FFFFFFFF' } };
        headerRow.fill = {
            type: 'pattern',
            pattern: 'solid',
            fgColor: { argb: 'FF667eea' }
        };
        headerRow.alignment = { horizontal: 'center', vertical: 'middle' };
        headerRow.height = 25;

        // Add project data
        this.results.projects.forEach(project => {
            const p = project.project;
            const s = project.summary;
            const d = project.dependencies || { direct: 0, transitive: 0 };

            const row = sheet.addRow([
                p.path || '',
                p.name || 'Unknown',
                p.artifactId || '-',
                p.javaVersion || 'unknown',
                d.direct || 0,
                d.transitive || 0,
                s.critical || 0,
                s.high || 0,
                s.medium || 0,
                s.low || 0
            ]);

            // Color code severity cells
            this.applySeverityColors(row, 7, s.critical, 'FF3B3B');
            this.applySeverityColors(row, 8, s.high, 'FF8C00');
            this.applySeverityColors(row, 9, s.medium, 'FFD700');
            this.applySeverityColors(row, 10, s.low, '4A9EFF');
        });

        // Auto-fit columns
        sheet.getColumn(1).width = 50; // Project Path
        sheet.getColumn(2).width = 30; // Project Name
        sheet.getColumn(3).width = 25; // Artifact ID
        sheet.getColumn(4).width = 15; // Java Version
        sheet.getColumn(5).width = 12; // Direct Deps
        sheet.getColumn(6).width = 15; // Transitive Deps
        sheet.getColumn(7).width = 12; // Critical
        sheet.getColumn(8).width = 12; // High
        sheet.getColumn(9).width = 12; // Medium
        sheet.getColumn(10).width = 12; // Low

        // Center align counts
        for (let i = 4; i <= 10; i++) {
            sheet.getColumn(i).alignment = { horizontal: 'center' };
        }

        // Add filters
        sheet.autoFilter = {
            from: 'A1',
            to: `J${sheet.rowCount}`
        };

        // Freeze header row
        sheet.views = [{ state: 'frozen', ySplit: 1 }];
    }

    /**
     * Create vulnerabilities detail sheet
     */
    createVulnerabilitiesSheet() {
        const sheet = this.workbook.addWorksheet('Vulnerabilities', {
            properties: { tabColor: { argb: 'FFFF8C00' } }
        });

        // Headers
        const headers = [
            'Project Path',
            'Project Name',
            'Project Key',
            'CVE ID',
            'Severity',
            'CVSS Score',
            'Dependency',
            'Version',
            'Description',
            'Published Date',
            'CWEs'
        ];

        sheet.addRow(headers);

        // Style header row
        const headerRow = sheet.getRow(1);
        headerRow.font = { bold: true, color: { argb: 'FFFFFFFF' } };
        headerRow.fill = {
            type: 'pattern',
            pattern: 'solid',
            fgColor: { argb: 'FF667eea' }
        };
        headerRow.alignment = { horizontal: 'center', vertical: 'middle' };
        headerRow.height = 25;

        // Add vulnerability data
        this.results.projects.forEach(project => {
            project.vulnerabilities.forEach(vuln => {
                const cwes = Array.isArray(vuln.cwes) ? vuln.cwes : [];

                const row = sheet.addRow([
                    project.project.path || '',
                    project.project.name || '',
                    project.project.key || '',
                    vuln.cveId || '',
                    vuln.cvss?.severity || 'UNKNOWN',
                    vuln.cvss?.score || 0,
                    `${(vuln.dependency?.groupId || '')}:${(vuln.dependency?.artifactId || '')}`,
                    vuln.dependency?.version || '',
                    vuln.description || '',
                    vuln.published || '',
                    cwes.join(', ')
                ]);

                // Color code severity
                const severityColors = {
                    'CRITICAL': 'FFFF3B3B',
                    'HIGH': 'FFFF8C00',
                    'MEDIUM': 'FFFFD700',
                    'LOW': 'FF4A9EFF'
                };

                const color = severityColors[vuln.cvss.severity] || 'FFA0A0A0';
                row.getCell(5).font = { bold: true, color: { argb: color } };
                row.getCell(6).font = { bold: true, color: { argb: color } };
            });
        });

        // Auto-fit columns
        try {
            if (sheet.columns) {
                sheet.columns.forEach((column, idx) => {
                    const widths = [50, 25, 30, 18, 12, 12, 40, 15, 80, 15, 20];
                    column.width = widths[idx] || 15;

                    if (idx === 8) { // Description column
                        column.alignment = { wrapText: true, vertical: 'top' };
                    } else if (idx >= 4 && idx <= 6) { // Severity and score
                        column.alignment = { horizontal: 'center' };
                    }
                });
            }
        } catch (e) {
            console.warn('  âš ï¸  Auto-fit columns failed (skippable):', e.message);
        }

        // Add filters
        sheet.autoFilter = {
            from: 'A1',
            to: `K${sheet.rowCount}`
        };

        // Freeze header row
        sheet.views = [{ state: 'frozen', ySplit: 1 }];
    }

    /**
     * Create CVE details sheet
     */
    createCVEDetailsSheet() {
        const sheet = this.workbook.addWorksheet('CVE Details', {
            properties: { tabColor: { argb: 'FFFFD700' } }
        });

        // Collect unique CVEs
        const cveMap = new Map();
        this.results.projects.forEach(project => {
            project.vulnerabilities.forEach(vuln => {
                if (!cveMap.has(vuln.cveId)) {
                    cveMap.set(vuln.cveId, vuln);
                }
            });
        });

        // Headers
        const headers = [
            'CVE ID',
            'Severity',
            'CVSS Score',
            'CVSS Vector',
            'CWEs',
            'Description',
            'Published',
            'Updated',
            'References'
        ];

        sheet.addRow(headers);

        // Style header row
        const headerRow = sheet.getRow(1);
        headerRow.font = { bold: true, color: { argb: 'FFFFFFFF' } };
        headerRow.fill = {
            type: 'pattern',
            pattern: 'solid',
            fgColor: { argb: 'FF667eea' }
        };
        headerRow.alignment = { horizontal: 'center', vertical: 'middle' };
        headerRow.height = 25;

        // Add CVE data
        Array.from(cveMap.values()).forEach(vuln => {
            const cwes = Array.isArray(vuln.cwes) ? vuln.cwes : [];
            const refs = Array.isArray(vuln.references) ? vuln.references : [];

            sheet.addRow([
                vuln.cveId || '',
                vuln.cvss?.severity || 'UNKNOWN',
                vuln.cvss?.score || 0,
                vuln.cvss?.vector || '',
                cwes.join(', '),
                vuln.description || '',
                vuln.published || '',
                vuln.updated || '',
                refs.slice(0, 3).join('\n')
            ]);
        });

        // Auto-fit columns
        sheet.getColumn(1).width = 18;
        sheet.getColumn(2).width = 12;
        sheet.getColumn(3).width = 12;
        sheet.getColumn(4).width = 40;
        sheet.getColumn(5).width = 20;
        sheet.getColumn(6).width = 80;
        sheet.getColumn(7).width = 15;
        sheet.getColumn(8).width = 15;
        sheet.getColumn(9).width = 60;

        // Wrap text for long columns
        sheet.getColumn(6).alignment = { wrapText: true, vertical: 'top' };
        sheet.getColumn(9).alignment = { wrapText: true, vertical: 'top' };

        // Center align severity and scores
        sheet.getColumn(2).alignment = { horizontal: 'center' };
        sheet.getColumn(3).alignment = { horizontal: 'center' };

        // Add filters
        sheet.autoFilter = {
            from: 'A1',
            to: `I${sheet.rowCount}`
        };

        // Freeze header row
        sheet.views = [{ state: 'frozen', ySplit: 1 }];
    }

    /**
     * Apply severity colors to cells
     */
    applySeverityColors(row, columnIndex, value, color) {
        const cell = row.getCell(columnIndex);
        if (value > 0) {
            cell.font = { bold: true, color: { argb: color } };
        } else {
            cell.font = { color: { argb: 'FF808080' } };
        }
    }
}
