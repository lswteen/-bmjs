import fs from 'fs/promises';
import path from 'path';

/**
 * Recursively find files with specific extensions
 * Replaces 'glob' library functionality using native Node.js fs
 */
export async function findFiles(dir, pattern) {
    const results = [];
    console.log(`DEBUG: Scanning ${dir} for ${pattern}...`);

    try {
        // Check if dir exists
        try {
            await fs.access(dir);
        } catch (err) {
            console.error(`‚ùå Directory not accessible: ${dir} (${err.message})`);
            return [];
        }

        // Use recursive readdir (available in Node 20+)
        const entries = await fs.readdir(dir, { recursive: true, withFileTypes: true });
        // console.log(`DEBUG: Found ${entries.length} entries in ${dir}`);

        for (const entry of entries) {
            if (!entry.isFile()) continue;

            const fullPath = path.join(entry.parentPath || entry.path, entry.name);
            const name = entry.name.toLowerCase();
            const pat = pattern.toLowerCase();

            // Simple pattern matching
            if (pat.endsWith('*.json') && name.endsWith('.json')) {
                results.push(fullPath);
            } else if (pat.endsWith('pom.xml') && name === 'pom.xml') {
                results.push(fullPath);
            } else if (pat.includes('build.gradle') && name.startsWith('build.gradle')) {
                results.push(fullPath);
            } else if (pat.endsWith('build.xml') && name === 'build.xml') {
                results.push(fullPath);
            } else if (pat.endsWith('*.jar') && name.endsWith('.jar')) {
                results.push(fullPath);
            } else if (name === pat) { // Exact match fallback (e.g. CMakeLists.txt, conanfile.txt)
                results.push(fullPath);
            }
        }
    } catch (error) {
        console.warn(`Warning: Error scanning directory ${dir}: ${error.message}`);
    }

    return results;
}
