import { GitProject } from '../../domain/git/project.js';
import { GitRepository } from '../../domain/git/repository.js';

/**
 * Persistence Repository for Git Projects and Repositories (Infrastructure Layer)
 */
export class GitPersistenceRepository {
    constructor(db) {
        this.db = db;
    }

    async syncProjects(projects) {
        const lastSynced = new Date().toISOString();
        return new Promise((resolve, reject) => {
            this.db.serialize(() => {
                const stmt = this.db.prepare(`
                    INSERT OR REPLACE INTO git_projects (key, id, name, description, lastSynced)
                    VALUES (?, ?, ?, ?, ?)
                `);
                projects.forEach(p => {
                    const entity = p instanceof GitProject ? p : GitProject.fromDto(p);
                    stmt.run(entity.key, entity.id, entity.name, entity.description, lastSynced);
                });
                stmt.finalize(err => {
                    if (err) reject(err);
                    else resolve();
                });
            });
        });
    }

    async syncRepos(projectKey, repos) {
        const lastSynced = new Date().toISOString();
        return new Promise((resolve, reject) => {
            this.db.serialize(() => {
                const stmt = this.db.prepare(`
                    INSERT OR REPLACE INTO git_repos (projectKey, slug, id, name, description, lastSynced)
                    VALUES (?, ?, ?, ?, ?, ?)
                `);
                repos.forEach(r => {
                    const entity = r instanceof GitRepository ? r : GitRepository.fromDto(r, projectKey);
                    stmt.run(projectKey, entity.slug, entity.id, entity.name, entity.description || '', lastSynced);
                });
                stmt.finalize(err => {
                    if (err) reject(err);
                    else resolve();
                });
            });
        });
    }

    async getProjects(page = 1, pageSize = 25) {
        const offset = (page - 1) * pageSize;
        return new Promise((resolve, reject) => {
            this.db.get("SELECT COUNT(*) as count FROM git_projects", (err, row) => {
                const total = row ? row.count : 0;
                this.db.all("SELECT * FROM git_projects ORDER BY name ASC LIMIT ? OFFSET ?", [pageSize, offset], (err, rows) => {
                    if (err) reject(err);
                    else {
                        const projects = rows.map(r => {
                            const p = new GitProject(r);
                            p.lastSynced = r.lastSynced;
                            return p;
                        });
                        resolve({ total, rows: projects, page, pageSize });
                    }
                });
            });
        });
    }

    async getRepos(projectKey) {
        return new Promise((resolve, reject) => {
            this.db.all("SELECT * FROM git_repos WHERE projectKey = ? ORDER BY name ASC", [projectKey], (err, rows) => {
                if (err) reject(err);
                else {
                    const repos = rows.map(r => {
                        const repo = new GitRepository(r);
                        repo.lastSynced = r.lastSynced;
                        return repo;
                    });
                    resolve(repos);
                }
            });
        });
    }
}
