import semver from 'semver';

/**
 * Match vulnerabilities against project dependencies
 */
export class VulnerabilityMatcher {
    constructor(cveLoader) {
        this.cveLoader = cveLoader;
        this.matches = [];
    }

    /**
     * Match all projects against CVE database
     */
    matchProjects(projects) {
        console.log('ðŸ” Matching vulnerabilities...');
        const results = [];

        for (const project of projects) {
            const projectResult = this.matchProject(project);
            results.push(projectResult);
        }

        const totalVulns = results.reduce((sum, r) => sum + r.vulnerabilities.length, 0);
        console.log(`âœ… Found ${totalVulns} vulnerabilities across ${results.length} projects`);

        return results;
    }

    /**
     * Match a single project against CVE database
     */
    matchProject(project) {
        const vulnerabilities = [];
        const cves = this.cveLoader.getAllCVEs();

        // Check each dependency against all CVEs
        for (const dependency of project.dependencies) {
            const matches = this.findMatchingCVEs(dependency, cves);
            vulnerabilities.push(...matches);
        }

        return {
            project: {
                name: project.name,
                key: `${project.groupId}:${project.artifactId}`,
                artifactId: project.artifactId,
                type: project.type,
                javaVersion: project.javaVersion,
                path: project.path,
                buildFile: project.buildFile
            },
            dependencies: {
                direct: project.dependencies.length,
                transitive: 0 // TODO: Implement transitive dependency analysis
            },
            vulnerabilities: vulnerabilities,
            summary: this.generateSummary(vulnerabilities)
        };
    }

    /**
     * Find CVEs matching a specific dependency
     */
    findMatchingCVEs(dependency, cves) {
        const matches = [];

        for (const cve of cves) {
            // Check if this CVE affects this dependency
            for (const affected of cve.affected) {
                if (this.isMatch(dependency, affected)) {
                    matches.push({
                        cveId: cve.id,
                        dependency: {
                            groupId: dependency.groupId,
                            artifactId: dependency.artifactId,
                            version: dependency.version
                        },
                        cvss: cve.cvss,
                        description: cve.description,
                        references: cve.references,
                        cwes: cve.cwes,
                        published: cve.published,
                        affectedVersions: affected.versions
                    });
                }
            }
        }

        return matches;
    }

    /**
     * Check if a dependency matches an affected product
     */
    isMatch(dependency, affected) {
        // Normalize product and vendor names for comparison
        const depArtifact = dependency.artifactId.toLowerCase();
        const depGroup = dependency.groupId.toLowerCase();
        const depVersion = dependency.version;

        const affectedProduct = affected.product.toLowerCase();
        const affectedVendor = affected.vendor.toLowerCase();

        // Try various matching strategies
        const nameMatch =
            // Exact artifact match
            depArtifact === affectedProduct ||
            // Artifact contains product name
            depArtifact.includes(affectedProduct) ||
            affectedProduct.includes(depArtifact) ||
            // Group contains vendor name
            depGroup.includes(affectedVendor) ||
            affectedVendor.includes(depGroup) ||
            // Product is a common alias
            this.isCommonAlias(depArtifact, affectedProduct);

        if (!nameMatch) return false;

        // Check version match
        return this.isVersionAffected(depVersion, affected.versions);
    }

    /**
     * Check if dependency version is affected
     */
    isVersionAffected(depVersion, affectedVersions) {
        if (!affectedVersions || affectedVersions.length === 0) return true;

        // Clean version string for comparison
        const cleanVersion = this.cleanVersion(depVersion);

        for (const versionRange of affectedVersions) {
            const rangeStr = versionRange.version || '';
            const status = versionRange.status || 'affected';

            // Only consider "affected" status
            if (status !== 'affected') continue;

            // Try to match version range
            if (this.matchesVersionRange(cleanVersion, rangeStr)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Match version against a range string
     */
    matchesVersionRange(version, rangeStr) {
        if (!rangeStr || rangeStr === '*') return true;

        try {
            // Handle common range formats
            // Examples: "< 1.2.3", ">= 1.0.0, < 2.0.0", "1.2.3"

            // Convert to semver range format
            let semverRange = rangeStr
                .replace(/\s+/g, ' ')
                .trim();

            // Handle specific version
            if (!semverRange.includes('<') && !semverRange.includes('>') && !semverRange.includes('=')) {
                return semver.eq(version, semverRange);
            }

            // Use semver to check if version satisfies range
            return semver.satisfies(version, semverRange);
        } catch (error) {
            // If semver parsing fails, try simple string comparison
            return version === rangeStr;
        }
    }

    /**
     * Clean version string for semver comparison
     */
    cleanVersion(version) {
        if (!version || version === 'unknown') return '0.0.0';

        // Remove common prefixes
        version = version.replace(/^v/, '');

        // Handle versions like "1.8" -> "1.8.0"
        const parts = version.split('.');
        while (parts.length < 3) {
            parts.push('0');
        }

        return parts.join('.');
    }

    /**
     * Check if names are common aliases
     */
    isCommonAlias(name1, name2) {
        const aliases = {
            'log4j-core': ['log4j', 'log4j2'],
            'spring-core': ['spring', 'springframework'],
            'jackson-databind': ['jackson'],
            'commons-collections': ['commons-collections4']
        };

        for (const [canonical, aliasList] of Object.entries(aliases)) {
            if ((name1 === canonical && aliasList.includes(name2)) ||
                (name2 === canonical && aliasList.includes(name1))) {
                return true;
            }
        }

        return false;
    }

    /**
     * Generate vulnerability summary
     */
    generateSummary(vulnerabilities) {
        const summary = {
            total: vulnerabilities.length,
            critical: 0,
            high: 0,
            medium: 0,
            low: 0,
            none: 0
        };

        vulnerabilities.forEach(vuln => {
            const severity = vuln.cvss.severity.toLowerCase();
            if (summary.hasOwnProperty(severity)) {
                summary[severity]++;
            }
        });

        return summary;
    }

    /**
     * Get overall statistics
     */
    getOverallStats(results) {
        const stats = {
            totalProjects: results.length,
            projectsWithVulnerabilities: results.filter(r => r.vulnerabilities.length > 0).length,
            totalVulnerabilities: 0,
            uniqueCVEs: new Set(),
            bySeverity: {
                critical: 0,
                high: 0,
                medium: 0,
                low: 0,
                none: 0
            }
        };

        results.forEach(result => {
            stats.totalVulnerabilities += result.vulnerabilities.length;

            result.vulnerabilities.forEach(vuln => {
                stats.uniqueCVEs.add(vuln.cveId);
                const severity = vuln.cvss.severity.toLowerCase();
                if (stats.bySeverity.hasOwnProperty(severity)) {
                    stats.bySeverity[severity]++;
                }
            });
        });

        stats.uniqueCVEs = stats.uniqueCVEs.size;

        return stats;
    }
}
