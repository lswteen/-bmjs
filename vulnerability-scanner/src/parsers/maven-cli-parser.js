import { exec } from 'child_process';
import util from 'util';
import path from 'path';

const execAsync = util.promisify(exec);

/**
 * Parse Maven projects using 'mvn' CLI for deep transitive dependency analysis
 */
export class MavenCliParser {
    constructor() { }

    /**
     * Parse project by running 'mvn dependency:tree'
     */
    async parse(pomPath) {
        const dir = path.dirname(pomPath);

        console.log(`  ⏳ Running deep scan (mvn) on ${dir}...`);

        try {
            // Try to get output in semi-structured text format
            // We use -DoutputType=text because it's standard. JSON output requires a specific plugin version usage or extra setup.
            // For robustness, we will parse the standard tree output.
            const { stdout } = await execAsync('mvn dependency:tree -Dbatch-mode -DsuppressSnapshotUpdates', {
                cwd: dir,
                maxBuffer: 1024 * 1024 * 10 // 10MB buffer
            });

            return this.parseDependencyTree(stdout, pomPath);

        } catch (error) {
            console.warn(`  ⚠️  Maven CLI failed for ${dir}. Falling back to basic parsing. Error: ${error.message}`);
            throw error; // Rethrow to allow fallback to static parser
        }
    }

    /**
     * Parse the textual output of mvn dependency:tree
     */
    parseDependencyTree(output, pomPath) {
        const lines = output.split('\n');
        const dependencies = [];
        let projectInfo = {
            groupId: 'unknown',
            artifactId: 'unknown',
            version: 'unknown'
        };

        for (const line of lines) {
            const cleanLine = line.replace(/^\[INFO\] /, '').trim();

            // Detect project identifier (first element typically)
            // Format: groupId:artifactId:packaging:version
            if (!projectInfo.groupId && cleanLine.match(/^[^:]+:[^:]+:[^:]+:[^:]+/)) {
                const parts = cleanLine.split(':');
                if (parts.length >= 4) {
                    projectInfo = {
                        groupId: parts[0],
                        artifactId: parts[1],
                        version: parts[3]
                    };
                }
            }

            // Parse dependencies
            // Tree structure characters: +- \|/
            // Detailed format: groupId:artifactId:packaging:version:scope
            // Or: groupId:artifactId:packaging:classifier:version:scope
            const depMatch = cleanLine.match(/([a-zA-Z0-9._-]+):([a-zA-Z0-9._-]+):([a-zA-Z0-9._-]+)(?::([a-zA-Z0-9._-]+))?:([a-zA-Z0-9._-]+):([a-zA-Z0-9._-]+)/);

            if (depMatch) {
                // Ensure it's not the project itself line
                if (cleanLine.includes('Scanning for projects...') || cleanLine.includes('Reactor Build Order')) continue;

                // Simple parsing logic: split by colon
                // Parts usually: [groupId, artifactId, type, version, scope] 
                // BUT mvn tree output has prefix symbols like "+- " or "\- "

                // Let's strip the tree symbols first
                const content = cleanLine.replace(/^[+|\\ \-]+/, '');
                const parts = content.split(':');

                if (parts.length >= 5) {
                    // Standard: G:A:T:V:S
                    // classifier might inject an extra field
                    const groupId = parts[0];
                    const artifactId = parts[1];
                    const type = parts[2];
                    let version = parts[3];
                    let scope = parts[4];

                    // Adjust for classifier if 6 parts
                    if (parts.length === 6) {
                        version = parts[4];
                        scope = parts[5];
                    }

                    if (scope && scope !== 'test' && groupId && artifactId) {
                        dependencies.push({
                            groupId,
                            artifactId,
                            version,
                            scope: scope,
                            isTransitive: true // Mark as transitive (we don't distinguish direct/transitive easily from simple tree output without depth check, but for deep scan purposes they are all "resolved dependencies")
                        });
                    }
                }
            }
        }

        return {
            type: 'maven',
            name: projectInfo.artifactId,
            groupId: projectInfo.groupId,
            artifactId: projectInfo.artifactId,
            version: projectInfo.version,
            javaVersion: 'unknown', // CLI doesn't easily Output java version used for compiling unless we check properties
            dependencies: dependencies,
            path: path.dirname(pomPath),
            buildFile: pomPath
        };
    }
}
