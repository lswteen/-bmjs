import { XMLParser } from 'fast-xml-parser';

/**
 * Parse Maven pom.xml files
 */
export class MavenParser {
    constructor() {
        this.parser = new XMLParser({
            ignoreAttributes: false,
            attributeNamePrefix: '@_'
        });
    }

    /**
     * Parse pom.xml content
     */
    async parse(pomContent) {
        try {
            const pom = this.parser.parse(pomContent);
            const project = pom.project || {};

            return {
                type: 'maven',
                name: this.extractText(project.name) || this.extractText(project.artifactId) || 'unknown',
                groupId: this.extractText(project.groupId) || 'unknown',
                artifactId: this.extractText(project.artifactId) || 'unknown',
                version: this.extractText(project.version) || '0.0.0',
                javaVersion: this.extractJavaVersion(project),
                dependencies: this.extractDependencies(project),
                properties: this.extractProperties(project)
            };
        } catch (error) {
            throw new Error(`Failed to parse pom.xml: ${error.message}`);
        }
    }

    /**
     * Extract text value from XML element
     */
    extractText(element) {
        if (element === null || element === undefined) return null;
        if (typeof element === 'string') return element;
        if (typeof element === 'number') return String(element);
        if (element['#text']) return String(element['#text']);
        return null;
    }

    /**
     * Extract Java version from pom.xml
     */
    extractJavaVersion(project) {
        const properties = project.properties || {};

        // Check common Java version properties
        const javaVersionKeys = [
            'java.version',
            'maven.compiler.source',
            'maven.compiler.target',
            'maven.compiler.release'
        ];

        for (const key of javaVersionKeys) {
            const version = this.extractText(properties[key]);
            if (version) return version;
        }

        // Check compiler plugin configuration
        const build = project.build || {};
        const plugins = this.normalizeArray(build.plugins?.plugin);

        for (const plugin of plugins) {
            const artifactId = this.extractText(plugin.artifactId);
            if (artifactId === 'maven-compiler-plugin') {
                const config = plugin.configuration || {};
                const source = this.extractText(config.source);
                const target = this.extractText(config.target);
                const release = this.extractText(config.release);

                return release || target || source || 'unknown';
            }
        }

        return 'unknown';
    }

    /**
     * Extract dependencies from pom.xml
     */
    extractDependencies(project) {
        const dependencies = [];
        const properties = this.extractProperties(project);

        // Extract regular dependencies
        const deps = this.normalizeArray(project.dependencies?.dependency);

        for (const dep of deps) {
            const groupId = this.extractText(dep.groupId);
            const artifactId = this.extractText(dep.artifactId);
            let version = this.extractText(dep.version);
            const scope = this.extractText(dep.scope) || 'compile';

            // Skip test dependencies
            if (scope === 'test') continue;

            // Resolve property placeholders
            if (version) {
                version = this.resolveProperties(version, properties);
            }

            if (groupId && artifactId) {
                dependencies.push({
                    groupId,
                    artifactId,
                    version: version || 'unknown',
                    scope
                });
            }
        }

        return dependencies;
    }

    /**
     * Extract properties from pom.xml
     */
    extractProperties(project) {
        const properties = {};
        const propsElement = project.properties || {};

        for (const [key, value] of Object.entries(propsElement)) {
            const textValue = this.extractText(value);
            if (textValue) {
                properties[key] = textValue;
            }
        }

        // Add implicit properties
        properties['project.groupId'] = this.extractText(project.groupId);
        properties['project.artifactId'] = this.extractText(project.artifactId);
        properties['project.version'] = this.extractText(project.version);

        return properties;
    }

    /**
     * Resolve property placeholders like ${spring.version}
     */
    resolveProperties(value, properties) {
        if (!value || typeof value !== 'string') return value;

        const regex = /\$\{([^}]+)\}/g;
        return value.replace(regex, (match, propName) => {
            return properties[propName] || match;
        });
    }

    /**
     * Normalize array - handle single element or array
     */
    normalizeArray(element) {
        if (!element) return [];
        if (Array.isArray(element)) return element;
        return [element];
    }
}
