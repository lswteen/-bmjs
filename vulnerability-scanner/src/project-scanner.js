import fs from 'fs/promises';
import path from 'path';
import { findFiles } from './file-utils.js';
import { MavenParser } from './parsers/maven-parser.js';
import { MavenCliParser } from './parsers/maven-cli-parser.js';
import { GradleParser } from './parsers/gradle-parser.js';
import { AntParser } from './parsers/ant-parser.js';
import { CParser } from './parsers/c-parser.js';
import { config } from './config.js';

/**
 * Scan projects for dependencies
 */
export class ProjectScanner {
    constructor(scanPath = config.projectScanPath, deepScan = false, javaHome = null) {
        this.scanPath = scanPath;
        this.deepScan = deepScan;
        this.mavenParser = new MavenParser();
        this.mavenCliParser = new MavenCliParser(javaHome);
        this.gradleParser = new GradleParser();
        this.antParser = new AntParser();
        this.cParser = new CParser();
        this.projects = [];
    }

    /**
     * Scan directory for Java projects
     */
    async scanDirectory(baseDir = this.scanPath) {
        console.log(`ðŸ” Scanning for Java projects in: ${baseDir}`);

        // Find all build files
        const pomFiles = await findFiles(baseDir, 'pom.xml');
        const gradleFiles = await findFiles(baseDir, 'build.gradle');
        const antFiles = await findFiles(baseDir, 'build.xml');
        const cmakeFiles = await findFiles(baseDir, 'CMakeLists.txt');
        const conanFiles = await findFiles(baseDir, 'conanfile.txt');

        console.log(`  ðŸ“¦ Found ${pomFiles.length} Maven projects`);
        console.log(`  ðŸ“¦ Found ${gradleFiles.length} Gradle projects`);
        console.log(`  ðŸ“¦ Found ${antFiles.length} Ant projects`);
        console.log(`  ðŸ“¦ Found ${cmakeFiles.length + conanFiles.length} C/C++ projects`);

        // Parse Maven projects
        for (const pomFile of pomFiles) {
            try {
                const project = await this.parseMavenProject(pomFile);
                this.projects.push({
                    ...project,
                    path: path.dirname(pomFile),
                    buildFile: pomFile
                });
            } catch (error) {
                console.warn(`  âš ï¸  Failed to parse ${pomFile}: ${error.message}`);
            }
        }

        // Parse Gradle projects
        for (const gradleFile of gradleFiles) {
            try {
                const project = await this.parseGradleProject(gradleFile);
                this.projects.push({
                    ...project,
                    path: path.dirname(gradleFile),
                    buildFile: gradleFile
                });
            } catch (error) {
                console.warn(`  âš ï¸  Failed to parse ${gradleFile}: ${error.message}`);
            }
        }

        // Parse Ant projects
        for (const antFile of antFiles) {
            try {
                const project = await this.parseAntProject(antFile);
                this.projects.push({
                    ...project,
                    path: path.dirname(antFile),
                    buildFile: antFile
                });
            } catch (error) {
                console.warn(`  âš ï¸  Failed to parse ${antFile}: ${error.message}`);
            }
        }

        // Parse CMake projects
        for (const cmakeFile of cmakeFiles) {
            try {
                const project = await this.cParser.parse(cmakeFile);
                project.path = path.dirname(cmakeFile);
                project.buildFile = cmakeFile;
                this.projects.push(project);
            } catch (error) {
                console.warn(`  âš ï¸  Failed to parse ${cmakeFile}: ${error.message}`);
            }
        }

        // Parse Conan projects
        for (const conanFile of conanFiles) {
            try {
                const project = await this.cParser.parse(conanFile);
                project.path = path.dirname(conanFile);
                project.buildFile = conanFile;
                this.projects.push(project);
            } catch (error) {
                console.warn(`  âš ï¸  Failed to parse ${conanFile}: ${error.message}`);
            }
        }

        console.log(`âœ… Successfully parsed ${this.projects.length} projects`);
        return this.projects;
    }

    /**
     * Parse a Maven project
     */
    async parseMavenProject(pomFile) {
        if (this.deepScan) {
            try {
                return await this.mavenCliParser.parse(pomFile);
            } catch (error) {
                console.warn(`  âš ï¸  Deep scan failed, falling back to static parsing for ${pomFile}`);
                // Fallthrough to static parser
            }
        }
        const content = await fs.readFile(pomFile, 'utf8');
        return await this.mavenParser.parse(content);
    }

    /**
     * Parse a Gradle project
     */
    async parseGradleProject(gradleFile) {
        const content = await fs.readFile(gradleFile, 'utf8');
        const fileName = path.basename(gradleFile);
        return await this.gradleParser.parse(content, fileName);
    }

    /**
     * Parse an Ant project
     */
    async parseAntProject(antFile) {
        return await this.antParser.parse(antFile);
    }

    /**
     * Get all scanned projects
     */
    getProjects() {
        return this.projects;
    }

    /**
     * Get project statistics
     */
    getStats() {
        const stats = {
            totalProjects: this.projects.length,
            byType: {
                maven: this.projects.filter(p => p.type === 'maven').length,
                gradle: this.projects.filter(p => p.type === 'gradle').length,
                ant: this.projects.filter(p => p.type === 'ant').length,
                c_cpp: this.projects.filter(p => p.type === 'c_cpp').length
            },
            totalDependencies: this.projects.reduce((sum, p) => sum + p.dependencies.length, 0),
            byJavaVersion: {}
        };

        // Count projects by Java version
        this.projects.forEach(project => {
            const version = project.javaVersion;
            stats.byJavaVersion[version] = (stats.byJavaVersion[version] || 0) + 1;
        });

        return stats;
    }

    /**
     * Get unique dependencies across all projects
     */
    getUniqueDependencies() {
        const uniqueDeps = new Map();

        this.projects.forEach(project => {
            project.dependencies.forEach(dep => {
                const key = `${dep.groupId}:${dep.artifactId}`;
                if (!uniqueDeps.has(key)) {
                    uniqueDeps.set(key, {
                        groupId: dep.groupId,
                        artifactId: dep.artifactId,
                        versions: new Set()
                    });
                }
                uniqueDeps.get(key).versions.add(dep.version);
            });
        });

        return Array.from(uniqueDeps.values()).map(dep => ({
            ...dep,
            versions: Array.from(dep.versions)
        }));
    }
}
