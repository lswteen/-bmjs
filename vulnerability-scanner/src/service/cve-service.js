import path from 'path';
import { fileURLToPath } from 'url';
import fs from 'fs/promises';
import { CVELoader } from '../core/cve-loader.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const dbPath = path.join(__dirname, '..', '..', 'data', 'cve.db');

class CVEDatabase {
    constructor(sqlite3) {
        this.db = new sqlite3.Database(dbPath);
    }

    async init() {
        // Ensure data directory exists
        const dataDir = path.dirname(dbPath);
        try { await fs.mkdir(dataDir, { recursive: true }); } catch (e) { /* ignore */ }

        return new Promise((resolve, reject) => {
            this.db.serialize(() => {
                this.db.run(`
                    CREATE TABLE IF NOT EXISTS cves (
                        cveId TEXT PRIMARY KEY,
                        description TEXT,
                        cvssScore REAL,
                        severity TEXT,
                        vendor TEXT,
                        product TEXT,
                        datePublished TEXT
                    )
                `, (err) => {
                    if (err) reject(err);
                    else resolve();
                });
            });
        });
    }

    async insertCve(cve) {
        return new Promise((resolve, reject) => {
            const stmt = this.db.prepare(`
                INSERT OR REPLACE INTO cves (
                    cveId, description, cvssScore, severity, vendor, product, datePublished
                ) VALUES (?, ?, ?, ?, ?, ?, ?)
            `);

            stmt.run(
                cve.cveId,
                cve.description,
                cve.cvssScore,
                cve.severity,
                cve.vendor,
                cve.product,
                cve.datePublished,
                (err) => {
                    if (err) reject(err);
                    else resolve();
                }
            );
            stmt.finalize();
        });
    }

    async searchByProduct(product, page = 1, pageSize = 50) {
        const offset = (page - 1) * pageSize;
        const countPromise = new Promise((resolve, reject) => {
            this.db.get(
                "SELECT COUNT(*) as count FROM cves WHERE product LIKE ?",
                [`%${product}%`],
                (err, row) => {
                    if (err) reject(err);
                    else resolve(row.count);
                }
            );
        });

        const rowsPromise = new Promise((resolve, reject) => {
            this.db.all(
                "SELECT * FROM cves WHERE product LIKE ? ORDER BY cvssScore DESC LIMIT ? OFFSET ?",
                [`%${product}%`, pageSize, offset],
                (err, rows) => {
                    if (err) reject(err);
                    else resolve(rows);
                }
            );
        });

        const [total, rows] = await Promise.all([countPromise, rowsPromise]);
        return { total, rows, page, pageSize };
    }

    async getYearScoreDistribution(filters = {}) {
        return new Promise((resolve, reject) => {
            let whereClause = "WHERE datePublished IS NOT NULL";
            const params = [];

            if (filters.years && filters.years.length > 0) {
                const placeholders = filters.years.map(() => "?").join(",");
                whereClause += ` AND strftime('%Y', datePublished) IN (${placeholders})`;
                params.push(...filters.years);
            }

            if (filters.products && filters.products.length > 0) {
                const placeholders = filters.products.map(() => "?").join(",");
                whereClause += ` AND product IN (${placeholders})`;
                params.push(...filters.products);
            }

            const query = `
                SELECT 
                    CASE 
                        WHEN cvssScore >= 9.0 THEN 'CRITICAL'
                        WHEN cvssScore >= 7.0 THEN 'HIGH'
                        WHEN cvssScore >= 4.0 THEN 'MEDIUM'
                        ELSE 'LOW'
                    END as severity,
                    COUNT(*) as count
                FROM cves 
                ${whereClause}
                GROUP BY severity
                ORDER BY count DESC
            `;
            this.db.all(query, params, (err, rows) => {
                if (err) reject(err);
                else resolve(rows);
            });
        });
    }

    async getProductDistribution(limit = 20, filters = {}) {
        return new Promise((resolve, reject) => {
            let whereClause = "WHERE product != '' AND product IS NOT NULL AND LOWER(product) NOT IN ('n/a', 'unknown')";
            const params = [];

            if (filters.years && filters.years.length > 0) {
                const placeholders = filters.years.map(() => "?").join(",");
                whereClause += ` AND strftime('%Y', datePublished) IN (${placeholders})`;
                params.push(...filters.years);
            }

            const query = `
                SELECT product, COUNT(*) as count 
                FROM cves 
                ${whereClause}
                GROUP BY product 
                ORDER BY count DESC 
                LIMIT ?
            `;
            this.db.all(query, [...params, limit], (err, rows) => {
                if (err) reject(err);
                else resolve(rows);
            });
        });
    }

    async getYearlySeverityDistribution() {
        return new Promise((resolve, reject) => {
            const query = `
                SELECT 
                    strftime('%Y', datePublished) as year,
                    CASE 
                        WHEN cvssScore >= 9.0 THEN 'CRITICAL'
                        WHEN cvssScore >= 7.0 THEN 'HIGH'
                        WHEN cvssScore >= 4.0 THEN 'MEDIUM'
                        ELSE 'LOW'
                    END as severity,
                    COUNT(*) as count
                FROM cves 
                WHERE datePublished IS NOT NULL AND datePublished != 'Unknown'
                GROUP BY year, severity
                ORDER BY year ASC
            `;
            this.db.all(query, [], (err, rows) => {
                if (err) reject(err);
                else resolve(rows);
            });
        });
    }

    async getCvesByFilter(filters = {}, limit = 50) {
        return new Promise((resolve, reject) => {
            let whereClause = "WHERE 1=1";
            const params = [];

            if (filters.year) {
                whereClause += " AND strftime('%Y', datePublished) = ?";
                params.push(filters.year);
            }

            if (filters.severity) {
                const s = filters.severity.toUpperCase();
                if (s === 'CRITICAL') whereClause += " AND cvssScore >= 9.0";
                else if (s === 'HIGH') whereClause += " AND cvssScore >= 7.0 AND cvssScore < 9.0";
                else if (s === 'MEDIUM') whereClause += " AND cvssScore >= 4.0 AND cvssScore < 7.0";
                else if (s === 'LOW') whereClause += " AND cvssScore < 4.0";
            }

            const query = `
                SELECT cveId, severity, cvssScore, product, vendor, datePublished, description
                FROM cves 
                ${whereClause}
                ORDER BY cvssScore DESC
                LIMIT ?
            `;
            this.db.all(query, [...params, limit], (err, rows) => {
                if (err) reject(err);
                else resolve(rows);
            });
        });
    }

    async getFilterOptions() {
        const yearsPromise = new Promise((resolve, reject) => {
            this.db.all(
                "SELECT DISTINCT strftime('%Y', datePublished) as year FROM cves WHERE datePublished IS NOT NULL AND datePublished != 'Unknown' ORDER BY year DESC",
                [],
                (err, rows) => { if (err) reject(err); else resolve(rows.map(r => r.year).filter(y => y !== null)); }
            );
        });

        const productsPromise = new Promise((resolve, reject) => {
            // Get top 20 products for filtering
            this.db.all(
                "SELECT product FROM cves WHERE product != '' AND product IS NOT NULL AND LOWER(product) NOT IN ('n/a', 'unknown') GROUP BY product ORDER BY COUNT(*) DESC LIMIT 20",
                [],
                (err, rows) => { if (err) reject(err); else resolve(rows.map(r => r.product)); }
            );
        });

        const [years, products] = await Promise.all([yearsPromise, productsPromise]);
        return { years, products };
    }

    async getStats() {
        return new Promise((resolve, reject) => {
            this.db.get("SELECT COUNT(*) as count FROM cves", (err, row) => {
                if (err) reject(err);
                else resolve(row);
            });
        });
    }

    close() {
        this.db.close();
    }
}

class FallbackCVEDatabase {
    constructor() {
        this.cveLoader = new CVELoader();
        this.isLoaded = false;
    }

    async init() {
        if (this.isLoaded) return;
        console.log('ğŸ“¦ Fallback Service: Loading CVE data into memory...');
        await this.cveLoader.loadAll();
        this.isLoaded = true;
        console.log('âœ… Fallback Service: Data loaded successfully');
    }

    async searchByProduct(product, page = 1, pageSize = 50) {
        const cves = this.cveLoader.searchByProduct(product);
        const sorted = cves.sort((a, b) => b.cvss.score - a.cvss.score);
        const start = (page - 1) * pageSize;
        const rows = sorted.slice(start, start + pageSize).map(cve => ({
            cveId: cve.id,
            description: cve.description,
            cvssScore: cve.cvss.score,
            severity: cve.cvss.severity,
            vendor: cve.affected[0]?.vendor || 'unknown',
            product: cve.affected[0]?.product || 'unknown',
            datePublished: cve.published
        }));

        return {
            total: cves.length,
            rows,
            page,
            pageSize
        };
    }

    async getYearScoreDistribution(filters = {}) {
        const cves = this.cveLoader.getAllCVEs().filter(cve => {
            if (filters.years && filters.years.length > 0) {
                const year = cve.published.split('-')[0];
                if (!filters.years.includes(year)) return false;
            }
            if (filters.products && filters.products.length > 0) {
                const hasProduct = cve.affected.some(a => filters.products.includes(a.product));
                if (!hasProduct) return false;
            }
            return true;
        });

        const dist = {
            'CRITICAL': 0,
            'HIGH': 0,
            'MEDIUM': 0,
            'LOW': 0
        };

        cves.forEach(cve => {
            const sev = cve.cvss.severity.toUpperCase();
            if (dist.hasOwnProperty(sev)) dist[sev]++;
        });

        return Object.entries(dist).map(([severity, count]) => ({ severity, count }));
    }

    async getProductDistribution(limit = 20, filters = {}) {
        const products = new Map();
        this.cveLoader.getAllCVEs().forEach(cve => {
            if (filters.years && filters.years.length > 0) {
                const year = cve.published.split('-')[0];
                if (!filters.years.includes(year)) return;
            }

            cve.affected.forEach(a => {
                const p = a.product;
                if (!p || /^(n\/a|unknown)$/i.test(p)) return;
                products.set(p, (products.get(p) || 0) + 1);
            });
        });

        const sorted = [...products.entries()]
            .sort((a, b) => b[1] - a[1])
            .slice(0, limit)
            .map(([product, count]) => ({ product, count }));

        return sorted;
    }

    async getYearlySeverityDistribution() {
        const yearly = new Map();

        this.cveLoader.getAllCVEs().forEach(cve => {
            if (!cve.published || cve.published === 'Unknown') return;
            const year = cve.published.split('-')[0];
            if (!/^\d{4}$/.test(year)) return;

            const sev = cve.cvss.severity.toUpperCase();
            const key = `${year}_${sev}`;

            if (!yearly.has(year)) {
                yearly.set(year, { year, CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0 });
            }

            const stats = yearly.get(year);
            if (stats.hasOwnProperty(sev)) stats[sev]++;
        });

        const result = [];
        [...yearly.values()]
            .sort((a, b) => a.year.localeCompare(b.year))
            .forEach(stats => {
                ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW'].forEach(sev => {
                    if (stats[sev] > 0) {
                        result.push({ year: stats.year, severity: sev, count: stats[sev] });
                    }
                });
            });

        return result;
    }

    async getCvesByFilter(filters = {}, limit = 50) {
        const cves = this.cveLoader.getAllCVEs().filter(cve => {
            if (filters.year) {
                const year = cve.published.split('-')[0];
                if (year !== filters.year) return false;
            }
            if (filters.severity) {
                if (cve.cvss.severity.toUpperCase() !== filters.severity.toUpperCase()) return false;
            }
            return true;
        });

        return cves
            .sort((a, b) => b.cvss.score - a.cvss.score)
            .slice(0, limit)
            .map(cve => ({
                cveId: cve.id,
                severity: cve.cvss.severity,
                cvssScore: cve.cvss.score,
                product: cve.affected[0]?.product || 'unknown',
                vendor: cve.affected[0]?.vendor || 'unknown',
                datePublished: cve.published,
                description: cve.description
            }));
    }

    async getFilterOptions() {
        const stats = this.cveLoader.getStats();
        const years = Object.keys(stats.severityBreakdown).length > 0
            ? Array.from(new Set(this.cveLoader.getAllCVEs().map(c => c.published.split('-')[0]).filter(y => /^\d{4}$/.test(y)))).sort().reverse()
            : [];

        const productsMap = new Map();
        this.cveLoader.getAllCVEs().forEach(cve => {
            cve.affected.forEach(a => {
                const p = a.product;
                if (!p || /^(n\/a|unknown)$/i.test(p)) return;
                productsMap.set(p, (productsMap.get(p) || 0) + 1);
            });
        });

        const products = [...productsMap.entries()]
            .sort((a, b) => b[1] - a[1])
            .slice(0, 20)
            .map(([p]) => p);

        return { years, products };
    }

    async getStats() {
        return { count: this.cveLoader.getAllCVEs().length };
    }

    close() { }
}


const createDatabase = async () => {
    try {
        console.log('ğŸ” Attempting to load sqlite3...');
        const sqlite3Module = await import('sqlite3');
        const sqlite3 = sqlite3Module.default || sqlite3Module;
        console.log('âœ… sqlite3 loaded successfully');
        return new CVEDatabase(sqlite3);
    } catch (e) {
        console.warn('âš ï¸  SQLite load failed:', e.message);
        if (e.code === 'ERR_DLOPEN_FAILED' || e.message.includes('not a valid Win32 application')) {
            console.warn('ğŸ’¡ Tip: This is likely a platform mismatch with the native module.');
        }
        console.warn('ğŸ”„ Switching to Pure JavaScript Fallback (In-Memory)...');
        console.warn('ğŸ“¡ This will load CVE JSON files directly. It may take a moment.');
        return new FallbackCVEDatabase();
    }
};

export const cveDb = await createDatabase();
