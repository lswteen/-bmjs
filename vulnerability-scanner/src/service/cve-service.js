import sqlite3 from 'sqlite3';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const dbPath = path.join(__dirname, '..', '..', 'data', 'cve.db');

class CVEDatabase {
    constructor() {
        this.db = new sqlite3.Database(dbPath);
    }

    async init() {
        // Ensure data directory exists
        const dataDir = path.dirname(dbPath);
        try { await fs.mkdir(dataDir, { recursive: true }); } catch (e) { /* ignore */ }

        return new Promise((resolve, reject) => {
            this.db.serialize(() => {
                this.db.run(`
                    CREATE TABLE IF NOT EXISTS cves (
                        cveId TEXT PRIMARY KEY,
                        description TEXT,
                        cvssScore REAL,
                        severity TEXT,
                        vendor TEXT,
                        product TEXT,
                        datePublished TEXT
                    )
                `, (err) => {
                    if (err) reject(err);
                    else resolve();
                });
            });
        });
    }

    async insertCve(cve) {
        return new Promise((resolve, reject) => {
            const stmt = this.db.prepare(`
                INSERT OR REPLACE INTO cves (
                    cveId, description, cvssScore, severity, vendor, product, datePublished
                ) VALUES (?, ?, ?, ?, ?, ?, ?)
            `);

            stmt.run(
                cve.cveId,
                cve.description,
                cve.cvssScore,
                cve.severity,
                cve.vendor,
                cve.product,
                cve.datePublished,
                (err) => {
                    if (err) reject(err);
                    else resolve();
                }
            );
            stmt.finalize();
        });
    }

    async searchByProduct(product, page = 1, pageSize = 50) {
        const offset = (page - 1) * pageSize;
        const countPromise = new Promise((resolve, reject) => {
            this.db.get(
                "SELECT COUNT(*) as count FROM cves WHERE product LIKE ?",
                [`%${product}%`],
                (err, row) => {
                    if (err) reject(err);
                    else resolve(row.count);
                }
            );
        });

        const rowsPromise = new Promise((resolve, reject) => {
            this.db.all(
                "SELECT * FROM cves WHERE product LIKE ? ORDER BY cvssScore DESC LIMIT ? OFFSET ?",
                [`%${product}%`, pageSize, offset],
                (err, rows) => {
                    if (err) reject(err);
                    else resolve(rows);
                }
            );
        });

        const [total, rows] = await Promise.all([countPromise, rowsPromise]);
        return { total, rows, page, pageSize };
    }

    async getYearScoreDistribution(filters = {}) {
        return new Promise((resolve, reject) => {
            let whereClause = "WHERE datePublished IS NOT NULL";
            const params = [];

            if (filters.years && filters.years.length > 0) {
                const placeholders = filters.years.map(() => "?").join(",");
                whereClause += ` AND strftime('%Y', datePublished) IN (${placeholders})`;
                params.push(...filters.years);
            }

            if (filters.products && filters.products.length > 0) {
                const placeholders = filters.products.map(() => "?").join(",");
                whereClause += ` AND product IN (${placeholders})`;
                params.push(...filters.products);
            }

            const query = `
                SELECT 
                    CASE 
                        WHEN cvssScore >= 9.0 THEN 'CRITICAL'
                        WHEN cvssScore >= 7.0 THEN 'HIGH'
                        WHEN cvssScore >= 4.0 THEN 'MEDIUM'
                        ELSE 'LOW'
                    END as severity,
                    COUNT(*) as count
                FROM cves 
                ${whereClause}
                GROUP BY severity
                ORDER BY count DESC
            `;
            this.db.all(query, params, (err, rows) => {
                if (err) reject(err);
                else resolve(rows);
            });
        });
    }

    async getProductDistribution(limit = 20, filters = {}) {
        return new Promise((resolve, reject) => {
            let whereClause = "WHERE product != '' AND product IS NOT NULL AND LOWER(product) NOT IN ('n/a', 'unknown')";
            const params = [];

            if (filters.years && filters.years.length > 0) {
                const placeholders = filters.years.map(() => "?").join(",");
                whereClause += ` AND strftime('%Y', datePublished) IN (${placeholders})`;
                params.push(...filters.years);
            }

            const query = `
                SELECT product, COUNT(*) as count 
                FROM cves 
                ${whereClause}
                GROUP BY product 
                ORDER BY count DESC 
                LIMIT ?
            `;
            this.db.all(query, [...params, limit], (err, rows) => {
                if (err) reject(err);
                else resolve(rows);
            });
        });
    }

    async getYearlySeverityDistribution() {
        return new Promise((resolve, reject) => {
            const query = `
                SELECT 
                    strftime('%Y', datePublished) as year,
                    CASE 
                        WHEN cvssScore >= 9.0 THEN 'CRITICAL'
                        WHEN cvssScore >= 7.0 THEN 'HIGH'
                        WHEN cvssScore >= 4.0 THEN 'MEDIUM'
                        ELSE 'LOW'
                    END as severity,
                    COUNT(*) as count
                FROM cves 
                WHERE datePublished IS NOT NULL AND datePublished != 'Unknown'
                GROUP BY year, severity
                ORDER BY year ASC
            `;
            this.db.all(query, [], (err, rows) => {
                if (err) reject(err);
                else resolve(rows);
            });
        });
    }

    async getCvesByFilter(filters = {}, limit = 50) {
        return new Promise((resolve, reject) => {
            let whereClause = "WHERE 1=1";
            const params = [];

            if (filters.year) {
                whereClause += " AND strftime('%Y', datePublished) = ?";
                params.push(filters.year);
            }

            if (filters.severity) {
                const s = filters.severity.toUpperCase();
                if (s === 'CRITICAL') whereClause += " AND cvssScore >= 9.0";
                else if (s === 'HIGH') whereClause += " AND cvssScore >= 7.0 AND cvssScore < 9.0";
                else if (s === 'MEDIUM') whereClause += " AND cvssScore >= 4.0 AND cvssScore < 7.0";
                else if (s === 'LOW') whereClause += " AND cvssScore < 4.0";
            }

            const query = `
                SELECT cveId, severity, cvssScore, product, vendor, datePublished, description
                FROM cves 
                ${whereClause}
                ORDER BY cvssScore DESC
                LIMIT ?
            `;
            this.db.all(query, [...params, limit], (err, rows) => {
                if (err) reject(err);
                else resolve(rows);
            });
        });
    }

    async getFilterOptions() {
        const yearsPromise = new Promise((resolve, reject) => {
            this.db.all(
                "SELECT DISTINCT strftime('%Y', datePublished) as year FROM cves WHERE datePublished IS NOT NULL AND datePublished != 'Unknown' ORDER BY year DESC",
                [],
                (err, rows) => { if (err) reject(err); else resolve(rows.map(r => r.year).filter(y => y !== null)); }
            );
        });

        const productsPromise = new Promise((resolve, reject) => {
            // Get top 20 products for filtering
            this.db.all(
                "SELECT product FROM cves WHERE product != '' AND product IS NOT NULL AND LOWER(product) NOT IN ('n/a', 'unknown') GROUP BY product ORDER BY COUNT(*) DESC LIMIT 20",
                [],
                (err, rows) => { if (err) reject(err); else resolve(rows.map(r => r.product)); }
            );
        });

        const [years, products] = await Promise.all([yearsPromise, productsPromise]);
        return { years, products };
    }

    async getStats() {
        return new Promise((resolve, reject) => {
            this.db.get("SELECT COUNT(*) as count FROM cves", (err, row) => {
                if (err) reject(err);
                else resolve(row);
            });
        });
    }

    close() {
        this.db.close();
    }
}

export const cveDb = new CVEDatabase();
