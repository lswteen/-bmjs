import path from 'path';
import { fileURLToPath } from 'url';
import fs from 'fs/promises';
import { CVELoader } from '../core/cve-loader.js';

import { GitPersistenceRepository } from '../infrastructure/persistence/git-persistence-repository.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const dbPath = path.join(__dirname, '..', '..', 'data', 'cve.db');

class CVEDatabase {
    constructor(sqlite3) {
        this.db = new sqlite3.Database(dbPath);
        this.gitRepos = new GitPersistenceRepository(this.db);
        this.initialized = false;
    }

    async init() {
        if (this.initialized) return;
        // Ensure data directory exists
        const dataDir = path.dirname(dbPath);
        try { await fs.mkdir(dataDir, { recursive: true }); } catch (e) { /* ignore */ }

        await new Promise((resolve, reject) => {
            this.db.serialize(() => {
                this.db.run(`
                    CREATE TABLE IF NOT EXISTS cves (
                        cveId TEXT PRIMARY KEY,
                        description TEXT,
                        cvssScore REAL,
                        severity TEXT,
                        vendor TEXT,
                        product TEXT,
                        datePublished TEXT
                    )
                `, (err) => {
                    if (err) reject(err);
                });

                this.db.run(`
                    CREATE TABLE IF NOT EXISTS git_projects (
                        key TEXT PRIMARY KEY,
                        id INTEGER,
                        name TEXT,
                        description TEXT,
                        lastSynced TEXT
                    )
                `, (err) => {
                    if (err) reject(err);
                });

                this.db.run(`
                    CREATE TABLE IF NOT EXISTS git_repos (
                        projectKey TEXT,
                        slug TEXT,
                        id INTEGER,
                        name TEXT,
                        description TEXT,
                        lastSynced TEXT,
                        PRIMARY KEY (projectKey, slug)
                    )
                `, (err) => {
                    if (err) reject(err);
                    else resolve();
                });
            });
        });
        this.initialized = true;
    }

    async syncGitProjects(projects) {
        const lastSynced = new Date().toISOString();
        return new Promise((resolve, reject) => {
            this.db.serialize(() => {
                const stmt = this.db.prepare(`
                    INSERT OR REPLACE INTO git_projects (key, id, name, description, lastSynced)
                    VALUES (?, ?, ?, ?, ?)
                `);
                projects.forEach(p => {
                    stmt.run(p.key, p.id, p.name, p.description, lastSynced);
                });
                stmt.finalize(err => {
                    if (err) reject(err);
                    else resolve();
                });
            });
        });
    }

    async syncGitRepos(projectKey, repos) {
        const lastSynced = new Date().toISOString();
        return new Promise((resolve, reject) => {
            this.db.serialize(() => {
                const stmt = this.db.prepare(`
                    INSERT OR REPLACE INTO git_repos (projectKey, slug, id, name, description, lastSynced)
                    VALUES (?, ?, ?, ?, ?, ?)
                `);
                repos.forEach(r => {
                    stmt.run(projectKey, r.slug, r.id, r.name, r.description || '', lastSynced);
                });
                stmt.finalize(err => {
                    if (err) reject(err);
                    else resolve();
                });
            });
        });
    }

    async getGitProjects(page = 1, pageSize = 25) {
        const offset = (page - 1) * pageSize;
        return new Promise((resolve, reject) => {
            this.db.get("SELECT COUNT(*) as count FROM git_projects", (err, row) => {
                const total = row ? row.count : 0;
                this.db.all("SELECT * FROM git_projects ORDER BY name ASC LIMIT ? OFFSET ?", [pageSize, offset], (err, rows) => {
                    if (err) reject(err);
                    else resolve({ total, rows, page, pageSize });
                });
            });
        });
    }

    async getGitRepos(projectKey) {
        return new Promise((resolve, reject) => {
            this.db.all("SELECT * FROM git_repos WHERE projectKey = ? ORDER BY name ASC", [projectKey], (err, rows) => {
                if (err) reject(err);
                else resolve(rows || []);
            });
        });
    }

    async insertCve(cve) {
        return this.insertCves([cve]);
    }

    async insertCves(cves) {
        if (!cves || cves.length === 0) return;
        return new Promise((resolve, reject) => {
            this.db.serialize(() => {
                this.db.run("BEGIN TRANSACTION");
                const stmt = this.db.prepare(`
                    INSERT OR REPLACE INTO cves (
                        cveId, description, cvssScore, severity, vendor, product, datePublished
                    ) VALUES (?, ?, ?, ?, ?, ?, ?)
                `);

                cves.forEach(c => {
                    // Handle both flattened (DB style) and nested (Loader style) objects
                    const cveId = c.cveId || c.id;
                    const description = c.description;
                    const cvssScore = c.cvssScore !== undefined ? c.cvssScore : (c.cvss?.score || 0);
                    const severity = c.severity || (c.cvss?.severity || 'UNKNOWN');
                    const datePublished = c.datePublished || c.published;

                    if (c.affected && Array.isArray(c.affected)) {
                        // If it has multiple affected products, insert a row for each
                        c.affected.forEach(a => {
                            stmt.run(cveId, description, cvssScore, severity, a.vendor || 'unknown', a.product || 'unknown', datePublished);
                        });
                    } else {
                        stmt.run(cveId, description, cvssScore, severity, c.vendor || 'unknown', c.product || 'unknown', datePublished);
                    }
                });

                stmt.finalize();
                this.db.run("COMMIT", err => {
                    if (err) reject(err);
                    else resolve();
                });
            });
        });
    }

    async hasData() {
        return new Promise((resolve, reject) => {
            this.db.get("SELECT COUNT(*) as count FROM cves", (err, row) => {
                if (err) reject(err);
                else resolve(row && row.count > 0);
            });
        });
    }

    async loadAllToCache(cveLoader) {
        console.log('ğŸ“š Loading CVEs from SQLite into memory...');
        return new Promise((resolve, reject) => {
            this.db.all("SELECT * FROM cves", (err, rows) => {
                if (err) return reject(err);

                const cveMap = new Map();
                rows.forEach(row => {
                    if (!cveMap.has(row.cveId)) {
                        cveMap.set(row.cveId, {
                            id: row.cveId,
                            description: row.description,
                            cvss: { score: row.cvssScore, severity: row.severity },
                            published: row.datePublished,
                            affected: []
                        });
                    }
                    cveMap.get(row.cveId).affected.push({
                        vendor: row.vendor,
                        product: row.product
                    });
                });

                const cves = Array.from(cveMap.values());
                cveLoader.cveCache = cves;
                cves.forEach(c => cveLoader.addToIndex(c));
                cveLoader.stats.javaRelevantCVEs = cves.length;
                console.log(`âœ… Loaded ${cves.length} CVEs from database`);
                resolve(cves);
            });
        });
    }

    async searchByFilters(filters = {}, page = 1, pageSize = 50) {
        const product = filters.product || '';
        const cveId = filters.cveId || '';
        const offset = (page - 1) * pageSize;

        let whereClause = "WHERE 1=1";
        const params = [];

        if (product) {
            whereClause += " AND product LIKE ?";
            params.push(`%${product}%`);
        }
        if (cveId) {
            whereClause += " AND cveId LIKE ?";
            params.push(`%${cveId}%`);
        }

        const countPromise = new Promise((resolve, reject) => {
            this.db.get(
                `SELECT COUNT(*) as count FROM cves ${whereClause}`,
                params,
                (err, row) => {
                    if (err) reject(err);
                    else resolve(row.count);
                }
            );
        });

        const rowsPromise = new Promise((resolve, reject) => {
            this.db.all(
                `SELECT * FROM cves ${whereClause} ORDER BY cvssScore DESC LIMIT ? OFFSET ?`,
                [...params, pageSize, offset],
                (err, rows) => {
                    if (err) reject(err);
                    else resolve(rows);
                }
            );
        });

        const [total, rows] = await Promise.all([countPromise, rowsPromise]);
        return { total, rows, page, pageSize };
    }

    async searchByProduct(product, page = 1, pageSize = 50) {
        return this.searchByFilters({ product }, page, pageSize);
    }

    async getYearScoreDistribution(filters = {}) {
        return new Promise((resolve, reject) => {
            let whereClause = "WHERE datePublished IS NOT NULL";
            const params = [];

            if (filters.years && filters.years.length > 0) {
                const placeholders = filters.years.map(() => "?").join(",");
                whereClause += ` AND strftime('%Y', datePublished) IN (${placeholders})`;
                params.push(...filters.years);
            }

            if (filters.products && filters.products.length > 0) {
                const placeholders = filters.products.map(() => "?").join(",");
                whereClause += ` AND product IN (${placeholders})`;
                params.push(...filters.products);
            }

            const query = `
                SELECT 
                    CASE 
                        WHEN cvssScore >= 9.0 THEN 'CRITICAL'
                        WHEN cvssScore >= 7.0 THEN 'HIGH'
                        WHEN cvssScore >= 4.0 THEN 'MEDIUM'
                        ELSE 'LOW'
                    END as severity,
                    COUNT(*) as count
                FROM cves 
                ${whereClause}
                GROUP BY severity
                ORDER BY count DESC
            `;
            this.db.all(query, params, (err, rows) => {
                if (err) reject(err);
                else resolve(rows);
            });
        });
    }

    async getProductDistribution(limit = 20, filters = {}) {
        return new Promise((resolve, reject) => {
            let whereClause = "WHERE product != '' AND product IS NOT NULL AND LOWER(product) NOT IN ('n/a', 'unknown')";
            const params = [];

            if (filters.years && filters.years.length > 0) {
                const placeholders = filters.years.map(() => "?").join(",");
                whereClause += ` AND strftime('%Y', datePublished) IN (${placeholders})`;
                params.push(...filters.years);
            }

            const query = `
                SELECT product, COUNT(*) as count 
                FROM cves 
                ${whereClause}
                GROUP BY product 
                ORDER BY count DESC 
                LIMIT ?
            `;
            this.db.all(query, [...params, limit], (err, rows) => {
                if (err) reject(err);
                else resolve(rows);
            });
        });
    }

    async getYearlySeverityDistribution() {
        return new Promise((resolve, reject) => {
            const query = `
                SELECT 
                    strftime('%Y', datePublished) as year,
                    CASE 
                        WHEN cvssScore >= 9.0 THEN 'CRITICAL'
                        WHEN cvssScore >= 7.0 THEN 'HIGH'
                        WHEN cvssScore >= 4.0 THEN 'MEDIUM'
                        ELSE 'LOW'
                    END as severity,
                    COUNT(*) as count
                FROM cves 
                WHERE datePublished IS NOT NULL AND datePublished != 'Unknown'
                GROUP BY year, severity
                ORDER BY year ASC
            `;
            this.db.all(query, [], (err, rows) => {
                if (err) reject(err);
                else resolve(rows);
            });
        });
    }

    async getCvesByFilter(filters = {}, limit = 50) {
        return new Promise((resolve, reject) => {
            let whereClause = "WHERE 1=1";
            const params = [];

            if (filters.year) {
                whereClause += " AND strftime('%Y', datePublished) = ?";
                params.push(filters.year);
            }

            if (filters.severity) {
                const s = filters.severity.toUpperCase();
                if (s === 'CRITICAL') whereClause += " AND cvssScore >= 9.0";
                else if (s === 'HIGH') whereClause += " AND cvssScore >= 7.0 AND cvssScore < 9.0";
                else if (s === 'MEDIUM') whereClause += " AND cvssScore >= 4.0 AND cvssScore < 7.0";
                else if (s === 'LOW') whereClause += " AND cvssScore < 4.0";
            }

            const query = `
                SELECT cveId, severity, cvssScore, product, vendor, datePublished, description
                FROM cves 
                ${whereClause}
                ORDER BY cvssScore DESC
                LIMIT ?
            `;
            this.db.all(query, [...params, limit], (err, rows) => {
                if (err) reject(err);
                else resolve(rows);
            });
        });
    }

    async getFilterOptions() {
        const yearsPromise = new Promise((resolve, reject) => {
            this.db.all(
                "SELECT DISTINCT strftime('%Y', datePublished) as year FROM cves WHERE datePublished IS NOT NULL AND datePublished != 'Unknown' ORDER BY year DESC",
                [],
                (err, rows) => { if (err) reject(err); else resolve(rows.map(r => r.year).filter(y => y !== null)); }
            );
        });

        const productsPromise = new Promise((resolve, reject) => {
            // Get top 20 products for filtering
            this.db.all(
                "SELECT product FROM cves WHERE product != '' AND product IS NOT NULL AND LOWER(product) NOT IN ('n/a', 'unknown') GROUP BY product ORDER BY COUNT(*) DESC LIMIT 20",
                [],
                (err, rows) => { if (err) reject(err); else resolve(rows.map(r => r.product)); }
            );
        });

        const [years, products] = await Promise.all([yearsPromise, productsPromise]);
        return { years, products };
    }

    async getStats() {
        return new Promise((resolve, reject) => {
            this.db.get("SELECT COUNT(*) as count FROM cves", (err, row) => {
                if (err) reject(err);
                else resolve(row);
            });
        });
    }

    close() {
        this.db.close();
    }
}

class FallbackCVEDatabase {
    constructor() {
        this.cveLoader = new CVELoader();
        this.isLoaded = false;
        this.gitProjectsPath = path.join(__dirname, '..', '..', 'data', 'git_projects.json');
        this.gitProjectsCache = null;
    }

    async init() {
        if (this.initialized) return;
        console.log('ğŸ“¦ Fallback Service: Loading CVE data into memory...');
        try {
            await this.cveLoader.loadAll();
            this.initialized = true;
            console.log('âœ… Fallback Service: Data loaded successfully');
        } catch (err) {
            console.error('âŒ Fallback Service: Failed to load data:', err.message);
            throw err;
        }
    }

    async searchByFilters(filters = {}, page = 1, pageSize = 50) {
        const product = (filters.product || '').toLowerCase();
        const cveId = (filters.cveId || '').toLowerCase();

        const cves = this.cveLoader.searchByProduct(product).filter(cve => {
            if (cveId && !cve.id.toLowerCase().includes(cveId)) return false;
            return true;
        });

        const sorted = cves.sort((a, b) => b.cvss.score - a.cvss.score);
        const start = (page - 1) * pageSize;
        const rows = sorted.slice(start, start + pageSize).map(cve => ({
            cveId: cve.id,
            description: cve.description,
            cvssScore: cve.cvss.score,
            severity: cve.cvss.severity,
            vendor: cve.affected[0]?.vendor || 'unknown',
            product: cve.affected[0]?.product || 'unknown',
            datePublished: cve.published
        }));

        return {
            total: cves.length,
            rows,
            page,
            pageSize
        };
    }

    async hasData() {
        return this.initialized && this.cveLoader.getAllCVEs().length > 0;
    }

    async loadAllToCache(cveLoader) {
        cveLoader.cveCache = this.cveLoader.cveCache;
        cveLoader.cveIndex = this.cveLoader.cveIndex;
        cveLoader.stats = this.cveLoader.stats;
    }

    async insertCves(cves) {
        // Fallback is read-only from JSON usually, but we can add to cache
        cves.forEach(c => {
            if (!this.cveLoader.cveCache.some(existing => existing.id === (c.cveId || c.id))) {
                const normalized = this.cveLoader.normalizeCVE ? c : this.cveLoader.normalizeCVE(c);
                this.cveLoader.cveCache.push(normalized);
                this.cveLoader.addToIndex(normalized);
            }
        });
    }

    async searchByProduct(product, page = 1, pageSize = 50) {
        return this.searchByFilters({ product }, page, pageSize);
    }

    async getYearScoreDistribution(filters = {}) {
        const cves = this.cveLoader.getAllCVEs().filter(cve => {
            if (filters.years && filters.years.length > 0) {
                const year = cve.published.split('-')[0];
                if (!filters.years.includes(year)) return false;
            }
            if (filters.products && filters.products.length > 0) {
                const hasProduct = cve.affected.some(a => filters.products.includes(a.product));
                if (!hasProduct) return false;
            }
            return true;
        });

        const dist = {
            'CRITICAL': 0,
            'HIGH': 0,
            'MEDIUM': 0,
            'LOW': 0
        };

        cves.forEach(cve => {
            const sev = cve.cvss.severity.toUpperCase();
            if (dist.hasOwnProperty(sev)) dist[sev]++;
        });

        return Object.entries(dist).map(([severity, count]) => ({ severity, count }));
    }

    async getProductDistribution(limit = 20, filters = {}) {
        const products = new Map();
        this.cveLoader.getAllCVEs().forEach(cve => {
            if (filters.years && filters.years.length > 0) {
                const year = cve.published.split('-')[0];
                if (!filters.years.includes(year)) return;
            }

            cve.affected.forEach(a => {
                const p = a.product;
                if (!p || /^(n\/a|unknown)$/i.test(p)) return;
                products.set(p, (products.get(p) || 0) + 1);
            });
        });

        const sorted = [...products.entries()]
            .sort((a, b) => b[1] - a[1])
            .slice(0, limit)
            .map(([product, count]) => ({ product, count }));

        return sorted;
    }

    async getYearlySeverityDistribution() {
        const yearly = new Map();

        this.cveLoader.getAllCVEs().forEach(cve => {
            if (!cve.published || cve.published === 'Unknown') return;
            const year = cve.published.split('-')[0];
            if (!/^\d{4}$/.test(year)) return;

            const sev = cve.cvss.severity.toUpperCase();
            const key = `${year}_${sev}`;

            if (!yearly.has(year)) {
                yearly.set(year, { year, CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0 });
            }

            const stats = yearly.get(year);
            if (stats.hasOwnProperty(sev)) stats[sev]++;
        });

        const result = [];
        [...yearly.values()]
            .sort((a, b) => a.year.localeCompare(b.year))
            .forEach(stats => {
                ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW'].forEach(sev => {
                    if (stats[sev] > 0) {
                        result.push({ year: stats.year, severity: sev, count: stats[sev] });
                    }
                });
            });

        return result;
    }

    async getCvesByFilter(filters = {}, limit = 50) {
        const cves = this.cveLoader.getAllCVEs().filter(cve => {
            if (filters.year) {
                const year = cve.published.split('-')[0];
                if (year !== filters.year) return false;
            }
            if (filters.severity) {
                if (cve.cvss.severity.toUpperCase() !== filters.severity.toUpperCase()) return false;
            }
            return true;
        });

        return cves
            .sort((a, b) => b.cvss.score - a.cvss.score)
            .slice(0, limit)
            .map(cve => ({
                cveId: cve.id,
                severity: cve.cvss.severity,
                cvssScore: cve.cvss.score,
                product: cve.affected[0]?.product || 'unknown',
                vendor: cve.affected[0]?.vendor || 'unknown',
                datePublished: cve.published,
                description: cve.description
            }));
    }

    async getFilterOptions() {
        const stats = this.cveLoader.getStats();
        const years = Object.keys(stats.severityBreakdown).length > 0
            ? Array.from(new Set(this.cveLoader.getAllCVEs().map(c => c.published.split('-')[0]).filter(y => /^\d{4}$/.test(y)))).sort().reverse()
            : [];

        const productsMap = new Map();
        this.cveLoader.getAllCVEs().forEach(cve => {
            cve.affected.forEach(a => {
                const p = a.product;
                if (!p || /^(n\/a|unknown)$/i.test(p)) return;
                productsMap.set(p, (productsMap.get(p) || 0) + 1);
            });
        });

        const products = [...productsMap.entries()]
            .sort((a, b) => b[1] - a[1])
            .slice(0, 20)
            .map(([p]) => p);

        return { years, products };
    }

    async getStats() {
        this.gitProjectsPath = path.join(__dirname, '..', '..', 'data', 'git_projects.json');
        this.gitReposPath = path.join(__dirname, '..', '..', 'data', 'git_repos.json');
        return { count: this.cveLoader.getAllCVEs().length };
    }

    async syncGitProjects(projects) {
        const lastSynced = new Date().toISOString();
        const data = projects.map(p => ({ ...p, lastSynced }));
        await fs.writeFile(this.gitProjectsPath, JSON.stringify(data, null, 2));
    }

    async syncGitRepos(projectKey, repos) {
        const lastSynced = new Date().toISOString();
        let allRepos = {};
        try {
            const content = await fs.readFile(this.gitReposPath, 'utf8');
            allRepos = JSON.parse(content);
        } catch (e) { /* ignore */ }

        allRepos[projectKey] = repos.map(r => ({ ...r, projectKey, lastSynced }));
        await fs.writeFile(this.gitReposPath, JSON.stringify(allRepos, null, 2));
    }

    async getGitProjects(page = 1, pageSize = 25) {
        try {
            const content = await fs.readFile(this.gitProjectsPath, 'utf8');
            const projects = JSON.parse(content);
            const offset = (page - 1) * pageSize;
            return {
                total: projects.length,
                rows: projects.slice(offset, offset + pageSize),
                page,
                pageSize
            };
        } catch (e) {
            return { total: 0, rows: [], page, pageSize };
        }
    }

    async getGitRepos(projectKey) {
        try {
            const content = await fs.readFile(this.gitReposPath, 'utf8');
            const allRepos = JSON.parse(content);
            return allRepos[projectKey] || [];
        } catch (e) {
            return [];
        }
    }

    close() { }
}


const createDatabase = async () => {
    try {
        console.log('ğŸ” Attempting to load sqlite3...');
        const sqlite3Module = await import('sqlite3');
        const sqlite3 = sqlite3Module.default || sqlite3Module;
        console.log('âœ… sqlite3 loaded successfully');
        return new CVEDatabase(sqlite3);
    } catch (e) {
        console.warn('âš ï¸  SQLite load failed:', e.message);
        if (e.code === 'ERR_DLOPEN_FAILED' || e.message.includes('not a valid Win32 application')) {
            console.warn('ğŸ’¡ Tip: This is likely a platform mismatch with the native module.');
        }
        console.warn('ğŸ”„ Switching to Pure JavaScript Fallback (In-Memory)...');
        console.warn('ğŸ“¡ This will load CVE JSON files directly. It may take a moment.');
        return new FallbackCVEDatabase();
    }
};

export const cveDb = await createDatabase();
