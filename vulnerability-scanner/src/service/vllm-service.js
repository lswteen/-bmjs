import { config } from '../core/config.js';
import { cveDb } from './cve-service.js';

/**
 * CVE ë³´ì•ˆ ì „ë¬¸ vLLM Chatbot Service
 * SQLite CVE ë°ì´í„°ë¥¼ ì»¨í…ìŠ¤íŠ¸ë¡œ í™œìš©í•œ RAG(Retrieval-Augmented Generation) êµ¬í˜„
 */

/**
 * CVE ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ê´€ë ¨ ì •ë³´ ê²€ìƒ‰
 * @param {string} query - ì‚¬ìš©ì ì§ˆë¬¸
 * @returns {Promise<Array>} - ê´€ë ¨ CVE ëª©ë¡
 */
async function retrieveRelevantCVEs(query) {
    try {
        const keywords = extractKeywords(query);
        const cves = [];

        // 1. CVE ID ì§ì ‘ ì–¸ê¸‰ í™•ì¸ (ì˜ˆ: CVE-2024-1234)
        const cveIdMatch = query.match(/CVE-\d{4}-\d+/gi);
        if (cveIdMatch) {
            for (const cveId of cveIdMatch) {
                const result = await cveDb.searchByFilters({ cveId }, 1, 5);
                cves.push(...result.rows);
            }
        }

        // 2. ì œí’ˆëª… ê¸°ë°˜ ê²€ìƒ‰
        for (const keyword of keywords) {
            if (keyword.length > 2) {
                const result = await cveDb.searchByFilters({ product: keyword }, 1, 10);
                cves.push(...result.rows);
            }
        }

        // 3. ì¤‘ë³µ ì œê±° ë° ì‹¬ê°ë„ ìˆœ ì •ë ¬
        const uniqueCves = Array.from(
            new Map(cves.map(cve => [cve.cveId, cve])).values()
        ).sort((a, b) => (b.cvssScore || 0) - (a.cvssScore || 0));

        return uniqueCves.slice(0, 15); // ìµœëŒ€ 15ê°œë¡œ ì œí•œ (í† í° ì ˆì•½)
    } catch (error) {
        console.error('CVE ê²€ìƒ‰ ì˜¤ë¥˜:', error);
        return [];
    }
}

/**
 * í‚¤ì›Œë“œ ì¶”ì¶œ (ê°„ë‹¨í•œ í† í°í™”)
 */
function extractKeywords(text) {
    const stopWords = new Set(['the', 'a', 'an', 'is', 'are', 'was', 'were', 'what', 'how', 'why', 'when', 'where', 'who']);
    return text
        .toLowerCase()
        .replace(/[^\w\sê°€-í£]/g, ' ')
        .split(/\s+/)
        .filter(word => word.length > 2 && !stopWords.has(word));
}

/**
 * CVE ë°ì´í„°ë¥¼ ì»¨í…ìŠ¤íŠ¸ ë¬¸ìì—´ë¡œ ë³€í™˜
 */
function formatCVEContext(cves) {
    if (!cves || cves.length === 0) {
        return 'ê´€ë ¨ CVE ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.';
    }

    return cves.map((cve, idx) => {
        return `[${idx + 1}] ${cve.cveId}
- ì œí’ˆ: ${cve.product} (${cve.vendor})
- ì‹¬ê°ë„: ${cve.severity} (CVSS ${cve.cvssScore})
- ì„¤ëª…: ${(cve.description || '').substring(0, 200)}...
- ë°œí–‰ì¼: ${cve.datePublished}`;
    }).join('\n\n');
}

/**
 * ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ ìƒì„± (CVE ì „ë¬¸ê°€ í˜ë¥´ì†Œë‚˜)
 */
function buildSystemPrompt(cveContext) {
    return `ë‹¹ì‹ ì€ CVE(Common Vulnerabilities and Exposures) ë³´ì•ˆ ì „ë¬¸ê°€ì…ë‹ˆë‹¤.

**ì—­í• :**
- ì‚¬ìš©ìì˜ ë³´ì•ˆ ì·¨ì•½ì  ê´€ë ¨ ì§ˆë¬¸ì— ì •í™•í•˜ê³  ì „ë¬¸ì ìœ¼ë¡œ ë‹µë³€í•©ë‹ˆë‹¤.
- ì œê³µëœ CVE ë°ì´í„°ë² ì´ìŠ¤ ì •ë³´ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ë‹µë³€í•©ë‹ˆë‹¤.
- ì·¨ì•½ì ì˜ ì‹¬ê°ë„, ì˜í–¥, ì™„í™” ë°©ë²•ì„ ëª…í™•íˆ ì„¤ëª…í•©ë‹ˆë‹¤.

**ë‹µë³€ ì›ì¹™:**
1. ì œê³µëœ CVE ë°ì´í„°ì— ê¸°ë°˜í•˜ì—¬ ë‹µë³€í•˜ì„¸ìš”.
2. CVE ID, ì œí’ˆëª…, ì‹¬ê°ë„ë¥¼ ëª…ì‹œí•˜ì„¸ìš”.
3. ê¸°ìˆ ì ì´ì§€ë§Œ ì´í•´í•˜ê¸° ì‰½ê²Œ ì„¤ëª…í•˜ì„¸ìš”.
4. ë°ì´í„°ì— ì—†ëŠ” ë‚´ìš©ì€ "ë°ì´í„°ë² ì´ìŠ¤ì— í•´ë‹¹ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤"ë¼ê³  ë‹µí•˜ì„¸ìš”.
5. í•œêµ­ì–´ë¡œ ë‹µë³€í•˜ì„¸ìš”.

**í˜„ì¬ ì œê³µëœ CVE ë°ì´í„°:**
${cveContext}

ìœ„ ë°ì´í„°ë¥¼ ì°¸ê³ í•˜ì—¬ ì‚¬ìš©ìì˜ ì§ˆë¬¸ì— ë‹µë³€í•˜ì„¸ìš”.`;
}

/**
 * vLLM API í˜¸ì¶œ (RAG ìµœì í™”)
 * @param {string} userMessage - ì‚¬ìš©ì ë©”ì‹œì§€
 * @param {Array} conversationHistory - ëŒ€í™” íˆìŠ¤í† ë¦¬
 * @returns {Promise<string>} - AI ì‘ë‹µ
 */
export async function callVLLMWithCVEContext(userMessage, conversationHistory = []) {
    try {
        // 1. ê´€ë ¨ CVE ê²€ìƒ‰ (RAG: Retrieval)
        console.log('ğŸ” CVE ë°ì´í„° ê²€ìƒ‰ ì¤‘...');
        const relevantCVEs = await retrieveRelevantCVEs(userMessage);

        // 2. ì»¨í…ìŠ¤íŠ¸ êµ¬ì„±
        const cveContext = formatCVEContext(relevantCVEs);
        const systemPrompt = buildSystemPrompt(cveContext);

        // 3. ë©”ì‹œì§€ êµ¬ì„± (ìµœê·¼ 5ê°œ ëŒ€í™”ë§Œ ìœ ì§€ - í† í° ì ˆì•½)
        const recentHistory = conversationHistory.slice(-5);
        const messages = [
            { role: 'system', content: systemPrompt },
            ...recentHistory,
            { role: 'user', content: userMessage }
        ];

        // 4. vLLM API í˜¸ì¶œ (RAG: Generation)
        console.log(`ğŸ¤– vLLM API í˜¸ì¶œ (ì»¨í…ìŠ¤íŠ¸: ${relevantCVEs.length}ê°œ CVE)`);

        // AbortController for timeout (5ë¶„)
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 300000); // 5ë¶„ íƒ€ì„ì•„ì›ƒ

        try {
            const response = await fetch(`${config.vllmApiUrl}/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                signal: controller.signal,
                body: JSON.stringify({
                    model: config.vllmModel,
                    messages: messages,
                    temperature: 0.3,  // ë‚®ì€ temperatureë¡œ ì •í™•ì„± í–¥ìƒ
                    max_tokens: 1000,  // ì¶©ë¶„í•œ í† í°ìœ¼ë¡œ ìƒì„¸ ë‹µë³€
                    top_p: 0.9,
                    frequency_penalty: 0.3,  // ë°˜ë³µ ê°ì†Œ
                    presence_penalty: 0.3    // ë‹¤ì–‘ì„± ì¦ê°€
                })
            });

            clearTimeout(timeoutId);

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`vLLM API Error (${response.status}): ${errorText}`);
            }

            const data = await response.json();
            const aiResponse = data.choices?.[0]?.message?.content;

            if (!aiResponse) {
                throw new Error('vLLM ì‘ë‹µì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.');
            }

            console.log('âœ… vLLM ì‘ë‹µ ì™„ë£Œ');
            return aiResponse;

        } catch (fetchError) {
            clearTimeout(timeoutId);

            if (fetchError.name === 'AbortError') {
                throw new Error('vLLM ì‘ë‹µ ì‹œê°„ ì´ˆê³¼ (5ë¶„). ì„œë²„ê°€ ì‘ë‹µí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
            }
            throw fetchError;
        }

    } catch (error) {
        console.error('âŒ vLLM í˜¸ì¶œ ì‹¤íŒ¨:', error);
        throw new Error(`AI ì‘ë‹µ ìƒì„± ì‹¤íŒ¨: ${error.message}`);
    }
}

/**
 * CVE í†µê³„ ì •ë³´ ê°€ì ¸ì˜¤ê¸° (ëŒ€ì‹œë³´ë“œìš©)
 */
export async function getCVEStatistics() {
    try {
        const stats = await cveDb.getStats();
        const severityDist = await cveDb.getYearScoreDistribution({});

        return {
            totalCVEs: stats.count,
            severityDistribution: severityDist,
            lastUpdated: new Date().toISOString()
        };
    } catch (error) {
        console.error('í†µê³„ ì¡°íšŒ ì‹¤íŒ¨:', error);
        return null;
    }
}

/**
 * íŠ¹ì • ì œí’ˆì˜ ì·¨ì•½ì  ìš”ì•½
 */
export async function getProductVulnerabilitySummary(productName) {
    try {
        const result = await cveDb.searchByFilters({ product: productName }, 1, 50);

        if (result.total === 0) {
            return `${productName}ì— ëŒ€í•œ CVE ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.`;
        }

        const critical = result.rows.filter(c => c.severity === 'CRITICAL').length;
        const high = result.rows.filter(c => c.severity === 'HIGH').length;
        const medium = result.rows.filter(c => c.severity === 'MEDIUM').length;
        const low = result.rows.filter(c => c.severity === 'LOW').length;

        return `**${productName} ì·¨ì•½ì  ìš”ì•½**
- ì´ CVE ìˆ˜: ${result.total}ê°œ
- CRITICAL: ${critical}ê°œ
- HIGH: ${high}ê°œ
- MEDIUM: ${medium}ê°œ
- LOW: ${low}ê°œ

ìµœê·¼ ì£¼ìš” ì·¨ì•½ì :
${result.rows.slice(0, 5).map((cve, idx) =>
            `${idx + 1}. ${cve.cveId} - ${cve.severity} (CVSS ${cve.cvssScore})`
        ).join('\n')}`;

    } catch (error) {
        console.error('ì œí’ˆ ìš”ì•½ ì‹¤íŒ¨:', error);
        return 'ìš”ì•½ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';
    }
}

/**
 * ë ˆê±°ì‹œ í˜¸í™˜ì„±ì„ ìœ„í•œ ê¸°ë³¸ callVLLM í•¨ìˆ˜
 */
export async function callVLLM(prompt, options = {}) {
    const {
        baseURL = config.vllmApiUrl,
        model = config.vllmModel,
        temperature = 0.7,
        maxTokens = 500,
        systemPrompt = 'You are a helpful assistant.'
    } = options;

    try {
        const response = await fetch(`${baseURL}/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                model: model,
                messages: [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: prompt }
                ],
                temperature: temperature,
                max_tokens: maxTokens
            })
        });

        if (!response.ok) {
            throw new Error(`vLLM API Error: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();
        const content = data.choices?.[0]?.message?.content;

        if (!content) {
            throw new Error('No content in vLLM response');
        }

        return content;

    } catch (error) {
        console.error('âŒ vLLM API í˜¸ì¶œ ì‹¤íŒ¨:', error.message);
        throw error;
    }
}
