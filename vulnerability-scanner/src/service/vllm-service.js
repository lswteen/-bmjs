import { config } from '../core/config.js';
import { cveDb } from './cve-service.js';
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * CVE ë³´ì•ˆ ì „ë¬¸ vLLM Chatbot Service
 * SQLite CVE ë°ì´í„°ë¥¼ ì»¨í…ìŠ¤íŠ¸ë¡œ í™œìš©í•œ RAG(Retrieval-Augmented Generation) êµ¬í˜„
 */

/**
 * ì·¨ì•½ì  ë¦¬í¬íŠ¸ ë°ì´í„° ë¡œë“œ
 * @returns {Promise<Object>} - vulnerability-report.json ë°ì´í„°
 */
async function loadVulnerabilityReport() {
    try {
        const reportPath = path.join(__dirname, '../../output/vulnerability-report.json');
        const reportData = await fs.readFile(reportPath, 'utf-8');
        return JSON.parse(reportData);
    } catch (error) {
        console.error('ì·¨ì•½ì  ë¦¬í¬íŠ¸ ë¡œë”© ì‹¤íŒ¨:', error);
        return null;
    }
}

/**
 * CVE ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ê´€ë ¨ ì •ë³´ ê²€ìƒ‰
 * @param {string} query - ì‚¬ìš©ì ì§ˆë¬¸
 * @returns {Promise<Array>} - ê´€ë ¨ CVE ëª©ë¡
 */
async function retrieveRelevantCVEs(query) {
    try {
        const keywords = extractKeywords(query);
        const cves = [];

        // 0. í†µê³„ ì§ˆì˜ í™•ì¸ (ê°œìˆ˜, ëª‡ê°œ, í†µê³„, count, total ë“±)
        const statsKeywords = ['ê°œìˆ˜', 'ëª‡ê°œ', 'í†µê³„', 'ì´', 'count', 'total', 'ì „ì²´', 'ìˆ˜ëŸ‰', 'í˜„í™©'];
        const isStatsQuery = statsKeywords.some(keyword => query.toLowerCase().includes(keyword));
        
        if (isStatsQuery) {
            // í†µê³„ ì •ë³´ ì¡°íšŒ
            const stats = await cveDb.getStats();
            const severityStats = await cveDb.getYearScoreDistribution({});
            
            // ê°€ìƒì˜ CVE ê°ì²´ë¡œ í†µê³„ ì •ë³´ë¥¼ ì „ë‹¬
            return [{
                cveId: 'STATS-TOTAL',
                product: 'Database Statistics',
                vendor: 'CVE Database',
                description: `ì „ì²´ CVE ê°œìˆ˜: ${stats.count}ê°œ. ì‹¬ê°ë„ë³„ ë¶„í¬ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.`,
                severity: 'INFO',
                cvssScore: 0,
                datePublished: new Date().toISOString().split('T')[0],
                statsData: { total: stats.count, distribution: severityStats }
            }];
        }

        // 0-1. í”„ë¡œì íŠ¸ë³„ ì·¨ì•½ì  ì§ˆì˜ í™•ì¸
        const projectKeywords = ['í”„ë¡œì íŠ¸', 'project', 'ì·¨ì•½ì  ë¦¬ìŠ¤íŠ¸', 'ì·¨ì•½ì  í˜„í™©', 'í”„ë¡œì íŠ¸ë³„'];
        const isProjectQuery = projectKeywords.some(keyword => query.toLowerCase().includes(keyword));
        
        if (isProjectQuery) {
            console.log('ğŸ” í”„ë¡œì íŠ¸ë³„ ì·¨ì•½ì  ë¦¬í¬íŠ¸ ê²€ìƒ‰ ì¤‘...');
            const reportData = await loadVulnerabilityReport();
            
            if (reportData && reportData.projects) {
                const projectsWithVulns = reportData.projects.filter(project => 
                    project.vulnerabilities && project.vulnerabilities.length > 0
                );
                
                if (projectsWithVulns.length > 0) {
                    console.log(`âœ… ì·¨ì•½ì ì´ ìˆëŠ” í”„ë¡œì íŠ¸ ${projectsWithVulns.length}ê°œ ë°œê²¬`);
                    
                    // í”„ë¡œì íŠ¸ ë°ì´í„°ë¥¼ CVE í˜•ì‹ìœ¼ë¡œ ë³€í™˜
                    return [{
                        cveId: 'PROJECT-REPORT',
                        product: 'Project Vulnerability Report',
                        vendor: 'Vulnerability Scanner',
                        description: `ìŠ¤ìº”ëœ í”„ë¡œì íŠ¸: ì´ ${reportData.projects.length}ê°œ, ì·¨ì•½ì  ë°œê²¬ í”„ë¡œì íŠ¸: ${projectsWithVulns.length}ê°œ`,
                        severity: 'INFO',
                        cvssScore: 0,
                        datePublished: new Date().toISOString().split('T')[0],
                        projectData: { 
                            totalProjects: reportData.projects.length,
                            vulnerableProjects: projectsWithVulns,
                            statistics: reportData.statistics
                        }
                    }];
                }
            }
        }

        // 1. CVE ID ì§ì ‘ ì–¸ê¸‰ í™•ì¸ (ì˜ˆ: CVE-1999-12345, CVE-2024-1234)
        const cveIdMatch = query.match(/CVE-(1999|20[0-1][0-9]|202[0-5])-\d+/gi);
        if (cveIdMatch) {
            for (const cveId of cveIdMatch) {
                const result = await cveDb.searchByFilters({ cveId }, 1, 5);
                cves.push(...result.rows);
            }
        }

        // 2. ì—°ë„ + ì œí’ˆ ì¡°í•© ê²€ìƒ‰ (ì˜ˆ: "2025 java", "cves-2025 java")
        const yearMatch = query.match(/(cves?-)?(\d{4})/gi);
        const hasJava = query.toLowerCase().includes('java');
        
        if (yearMatch && hasJava) {
            const year = yearMatch[0].replace(/cves?-?/gi, '');
            console.log(`ğŸ” ì—°ë„ë³„ Java CVE ê²€ìƒ‰: ${year}ë…„ë„ Java ê´€ë ¨`);
            
            // CVE ID íŒ¨í„´ìœ¼ë¡œ ì—°ë„ ê²€ìƒ‰ + Java ì œí’ˆ ê²€ìƒ‰
            const result1 = await cveDb.searchByFilters({ 
                cveId: `CVE-${year}-` 
            }, 1, 50);
            
            // Java ì œí’ˆìœ¼ë¡œ í•„í„°ë§
            const javaFilteredCves = result1.rows.filter(cve => 
                cve.product && cve.product.toLowerCase().includes('java')
            );
            
            if (javaFilteredCves.length > 0) {
                cves.push(...javaFilteredCves);
                console.log(`âœ… ${year}ë…„ë„ Java CVE ${javaFilteredCves.length}ê°œ ë°œê²¬`);
            }
        }

        // 3. ì¼ë°˜ ì œí’ˆëª… ê¸°ë°˜ ê²€ìƒ‰
        for (const keyword of keywords) {
            if (keyword.length > 2) {
                const result = await cveDb.searchByFilters({ product: keyword }, 1, 10);
                cves.push(...result.rows);
            }
        }

        // 4. ì¤‘ë³µ ì œê±° ë° ì‹¬ê°ë„ ìˆœ ì •ë ¬
        const uniqueCves = Array.from(
            new Map(cves.map(cve => [cve.cveId, cve])).values()
        ).sort((a, b) => (b.cvssScore || 0) - (a.cvssScore || 0));

        return uniqueCves.slice(0, 15); // ìµœëŒ€ 15ê°œë¡œ ì œí•œ (í† í° ì ˆì•½)
    } catch (error) {
        console.error('CVE ê²€ìƒ‰ ì˜¤ë¥˜:', error);
        return [];
    }
}

/**
 * í‚¤ì›Œë“œ ì¶”ì¶œ (ê°„ë‹¨í•œ í† í°í™”)
 */
function extractKeywords(text) {
    const stopWords = new Set(['the', 'a', 'an', 'is', 'are', 'was', 'were', 'what', 'how', 'why', 'when', 'where', 'who']);
    return text
        .toLowerCase()
        .replace(/[^\w\sê°€-í£]/g, ' ')
        .split(/\s+/)
        .filter(word => word.length > 2 && !stopWords.has(word));
}

/**
 * CVE ë°ì´í„°ë¥¼ ì»¨í…ìŠ¤íŠ¸ ë¬¸ìì—´ë¡œ ë³€í™˜
 */
function formatCVEContext(cves) {
    if (!cves || cves.length === 0) {
        return 'ê´€ë ¨ CVE ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.';
    }

    return cves.map((cve, idx) => {
        // í”„ë¡œì íŠ¸ ë¦¬í¬íŠ¸ ë°ì´í„° ì²˜ë¦¬
        if (cve.cveId === 'PROJECT-REPORT' && cve.projectData) {
            let context = `[${idx + 1}] ${cve.cveId}
- ì œí’ˆ: ${cve.product} (${cve.vendor})
- ì„¤ëª…: ${cve.description}
- ìŠ¤ìº” ì¼ì‹œ: ${cve.datePublished}

**í”„ë¡œì íŠ¸ë³„ ì·¨ì•½ì  í˜„í™©:**
`;
            
            cve.projectData.vulnerableProjects.forEach((project, pidx) => {
                context += `
${pidx + 1}. **${project.project.name}** (${project.project.type})
   - ê²½ë¡œ: ${project.project.path}
   - Java ë²„ì „: ${project.project.javaVersion}
   - ì·¨ì•½ì  ì´ ${project.summary.total}ê°œ (CRITICAL: ${project.summary.critical}, HIGH: ${project.summary.high}, MEDIUM: ${project.summary.medium}, LOW: ${project.summary.low})
   
   ì£¼ìš” ì·¨ì•½ì :`;
                
                project.vulnerabilities.forEach((vuln, vidx) => {
                    context += `
   - CVE-${vuln.cveId}: ${vuln.dependency.groupId}:${vuln.dependency.artifactId}:${vuln.dependency.version} (${vuln.cvss.severity})`;
                });
            });
            
            return context;
        }
        
        // ì¼ë°˜ CVE ë°ì´í„° ì²˜ë¦¬
        return `[${idx + 1}] ${cve.cveId}
- ì œí’ˆ: ${cve.product} (${cve.vendor})
- ì‹¬ê°ë„: ${cve.severity} (CVSS ${cve.cvssScore})
- ì„¤ëª…: ${(cve.description || '').substring(0, 200)}...
- ë°œí–‰ì¼: ${cve.datePublished}`;
    }).join('\n\n');
}

/**
 * ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ ìƒì„± (CVE ì „ë¬¸ê°€ í˜ë¥´ì†Œë‚˜)
 */
function buildSystemPrompt(cveContext) {
    return `ë‹¹ì‹ ì€ CVE(Common Vulnerabilities and Exposures) ë³´ì•ˆ ì „ë¬¸ê°€ì…ë‹ˆë‹¤.

**ì—­í• :**
- ì‚¬ìš©ìì˜ ë³´ì•ˆ ì·¨ì•½ì  ê´€ë ¨ ì§ˆë¬¸ì— ì •í™•í•˜ê³  ì „ë¬¸ì ìœ¼ë¡œ ë‹µë³€í•©ë‹ˆë‹¤.
- ì œê³µëœ CVE ë°ì´í„°ë² ì´ìŠ¤ ì •ë³´ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ë‹µë³€í•©ë‹ˆë‹¤.
- ì·¨ì•½ì ì˜ ì‹¬ê°ë„, ì˜í–¥, ì™„í™” ë°©ë²•ì„ ëª…í™•íˆ ì„¤ëª…í•©ë‹ˆë‹¤.

**ë‹µë³€ ì›ì¹™:**
1. ì œê³µëœ CVE ë°ì´í„°ì— ê¸°ë°˜í•˜ì—¬ ë‹µë³€í•˜ì„¸ìš”.
2. CVE ID, ì œí’ˆëª…, ì‹¬ê°ë„ë¥¼ ëª…ì‹œí•˜ì„¸ìš”.
3. ê¸°ìˆ ì ì´ì§€ë§Œ ì´í•´í•˜ê¸° ì‰½ê²Œ ì„¤ëª…í•˜ì„¸ìš”.
4. ë°ì´í„°ì— ì—†ëŠ” ë‚´ìš©ì€ "ë°ì´í„°ë² ì´ìŠ¤ì— í•´ë‹¹ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤"ë¼ê³  ë‹µí•˜ì„¸ìš”.
5. í•œêµ­ì–´ë¡œ ë‹µë³€í•˜ì„¸ìš”.

**í˜„ì¬ ì œê³µëœ CVE ë°ì´í„°:**
${cveContext}

ìœ„ ë°ì´í„°ë¥¼ ì°¸ê³ í•˜ì—¬ ì‚¬ìš©ìì˜ ì§ˆë¬¸ì— ë‹µë³€í•˜ì„¸ìš”.`;
}

/**
 * vLLM API í˜¸ì¶œ (RAG ìµœì í™”)
 * @param {string} userMessage - ì‚¬ìš©ì ë©”ì‹œì§€
 * @param {Array} conversationHistory - ëŒ€í™” íˆìŠ¤í† ë¦¬
 * @returns {Promise<string>} - AI ì‘ë‹µ
 */
export async function callVLLMWithCVEContext(userMessage, conversationHistory = []) {
    try {
        console.log('\n' + '='.repeat(80));
        console.log('ğŸš€ [RAG] CVE ê¸°ë°˜ AI ì‘ë‹µ ìƒì„± ì‹œì‘');
        console.log('='.repeat(80));
        console.log('ğŸ“ ì‚¬ìš©ì ì§ˆë¬¸:', userMessage);
        console.log('ğŸ“š ëŒ€í™” íˆìŠ¤í† ë¦¬:', conversationHistory.length, 'ê°œ ë©”ì‹œì§€');

        // 1. ê´€ë ¨ CVE ê²€ìƒ‰ (RAG: Retrieval)
        console.log('\nğŸ” [STEP 1] CVE ë°ì´í„°ë² ì´ìŠ¤ ê²€ìƒ‰ ì¤‘...');
        const relevantCVEs = await retrieveRelevantCVEs(userMessage);
        console.log(`âœ… ê²€ìƒ‰ ì™„ë£Œ: ${relevantCVEs.length}ê°œ ê´€ë ¨ CVE ë°œê²¬`);

        if (relevantCVEs.length > 0) {
            console.log('\nğŸ“Š [ê²€ìƒ‰ëœ CVE ëª©ë¡]:');
            relevantCVEs.forEach((cve, idx) => {
                console.log(`  ${idx + 1}. ${cve.cveId} - ${cve.severity} (CVSS ${cve.cvssScore}) - ${cve.product}`);
            });
        } else {
            console.log('âš ï¸  ê´€ë ¨ CVEë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ì¼ë°˜ ì‘ë‹µ ëª¨ë“œë¡œ ì „í™˜í•©ë‹ˆë‹¤.');
        }

        // 2. ì»¨í…ìŠ¤íŠ¸ êµ¬ì„±
        console.log('\nğŸ“ [STEP 2] RAG ì»¨í…ìŠ¤íŠ¸ êµ¬ì„± ì¤‘...');
        const cveContext = formatCVEContext(relevantCVEs);
        const systemPrompt = buildSystemPrompt(cveContext);

        console.log(`âœ… ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ ìƒì„± ì™„ë£Œ (${systemPrompt.length} ê¸€ì)`);
        console.log('\nğŸ“‹ [ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ ë¯¸ë¦¬ë³´ê¸°]:');
        console.log(systemPrompt.substring(0, 500) + '...\n');

        // 3. ë©”ì‹œì§€ êµ¬ì„± (ìµœê·¼ 5ê°œ ëŒ€í™”ë§Œ ìœ ì§€ - í† í° ì ˆì•½)
        const recentHistory = conversationHistory.slice(-5);
        const messages = [
            { role: 'system', content: systemPrompt },
            ...recentHistory,
            { role: 'user', content: userMessage }
        ];

        console.log(`ğŸ“¨ [STEP 3] vLLM ìš”ì²­ ë©”ì‹œì§€ êµ¬ì„± ì™„ë£Œ (ì´ ${messages.length}ê°œ ë©”ì‹œì§€)`);

        // 4. Ollama API í˜¸ì¶œ (RAG: Generation)
        console.log('\nğŸ¤– [STEP 4] Ollama API í˜¸ì¶œ ì‹œì‘...');
        console.log(`ğŸ“ ì—”ë“œí¬ì¸íŠ¸: ${config.vllmApiUrl}/generate`);
        console.log(`ğŸ¯ ëª¨ë¸: ${config.vllmModel}`);

        // Ollamaìš© í”„ë¡¬í”„íŠ¸ êµ¬ì„± (messagesë¥¼ single promptë¡œ ë³€í™˜)
        const fullPrompt = messages.map(msg => {
            if (msg.role === 'system') return msg.content;
            if (msg.role === 'user') return `ì‚¬ìš©ì: ${msg.content}`;
            if (msg.role === 'assistant') return `ì–´ì‹œìŠ¤í„´íŠ¸: ${msg.content}`;
            return msg.content;
        }).join('\n\n');

        const requestBody = {
            model: config.vllmModel,
            prompt: fullPrompt,
            stream: false,
            options: {
                temperature: 0.3,
                top_p: 0.9,
                num_predict: 1000
            }
        };

        console.log('ğŸ“¤ [ìš”ì²­ íŒŒë¼ë¯¸í„°]:');
        console.log(`  - Temperature: ${requestBody.options.temperature}`);
        console.log(`  - Max Tokens: ${requestBody.options.num_predict}`);
        console.log(`  - Top P: ${requestBody.options.top_p}`);
        console.log(`  - Prompt Length: ${fullPrompt.length}ê¸€ì`);

        // AbortController for timeout (5ë¶„)
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 300000);

        const startTime = Date.now();

        try {
            const response = await fetch(`${config.vllmApiUrl}/generate`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                signal: controller.signal,
                body: JSON.stringify(requestBody)
            });

            clearTimeout(timeoutId);
            const elapsed = ((Date.now() - startTime) / 1000).toFixed(2);

            console.log(`\nğŸ“¥ [ì‘ë‹µ ìˆ˜ì‹ ] (ì†Œìš” ì‹œê°„: ${elapsed}ì´ˆ)`);
            console.log(`  - ìƒíƒœ ì½”ë“œ: ${response.status} ${response.statusText}`);

            if (!response.ok) {
                const errorText = await response.text();
                console.error('âŒ [Ollama ì—ëŸ¬ ì‘ë‹µ]:', errorText);
                throw new Error(`Ollama API Error (${response.status}): ${errorText}`);
            }

            const data = await response.json();
            const aiResponse = data.response;

            if (!aiResponse) {
                console.error('âŒ [ì‘ë‹µ íŒŒì‹± ì‹¤íŒ¨] ì‘ë‹µ ë°ì´í„°:', JSON.stringify(data, null, 2));
                throw new Error('Ollama ì‘ë‹µì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.');
            }

            console.log('\nâœ… [AI ì‘ë‹µ ìƒì„± ì™„ë£Œ]');
            console.log(`ğŸ“Š ì‘ë‹µ ê¸¸ì´: ${aiResponse.length} ê¸€ì`);
            console.log('\nğŸ’¬ [AI ì‘ë‹µ ë¯¸ë¦¬ë³´ê¸°]:');
            console.log(aiResponse.substring(0, 300) + '...\n');

            if (data.eval_count || data.prompt_eval_count) {
                console.log('ğŸ“ˆ [í† í° ì‚¬ìš©ëŸ‰]:');
                console.log(`  - Prompt Eval Count: ${data.prompt_eval_count || 'N/A'}`);
                console.log(`  - Eval Count: ${data.eval_count || 'N/A'}`);
                console.log(`  - Total Duration: ${data.total_duration ? (data.total_duration/1000000).toFixed(2) + 'ms' : 'N/A'}`);
            }

            console.log('='.repeat(80));
            console.log('âœ… RAG í”„ë¡œì„¸ìŠ¤ ì™„ë£Œ\n');

            return aiResponse;

        } catch (fetchError) {
            clearTimeout(timeoutId);
            const elapsed = ((Date.now() - startTime) / 1000).toFixed(2);

            console.error(`\nâŒ [Ollama í˜¸ì¶œ ì‹¤íŒ¨] (ì†Œìš” ì‹œê°„: ${elapsed}ì´ˆ)`);

            if (fetchError.name === 'AbortError') {
                console.error('â±ï¸  íƒ€ì„ì•„ì›ƒ: 5ë¶„ ì´ˆê³¼');
                throw new Error('Ollama ì‘ë‹µ ì‹œê°„ ì´ˆê³¼ (5ë¶„). ì„œë²„ê°€ ì‘ë‹µí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
            }

            console.error('ğŸ”¥ ì—ëŸ¬ ìƒì„¸:', fetchError.message);
            console.error('ğŸ“ ìŠ¤íƒ:', fetchError.stack);
            throw fetchError;
        }

    } catch (error) {
        console.error('\n' + '='.repeat(80));
        console.error('âŒ [RAG í”„ë¡œì„¸ìŠ¤ ì‹¤íŒ¨]');
        console.error('='.repeat(80));
        console.error('ì—ëŸ¬ ë©”ì‹œì§€:', error.message);
        console.error('ì—ëŸ¬ ìŠ¤íƒ:', error.stack);
        console.error('='.repeat(80) + '\n');
        throw new Error(`AI ì‘ë‹µ ìƒì„± ì‹¤íŒ¨: ${error.message}`);
    }
}

/**
 * CVE í†µê³„ ì •ë³´ ê°€ì ¸ì˜¤ê¸° (ëŒ€ì‹œë³´ë“œìš©)
 */
export async function getCVEStatistics() {
    try {
        const stats = await cveDb.getStats();
        const severityDist = await cveDb.getYearScoreDistribution({});

        return {
            totalCVEs: stats.count,
            severityDistribution: severityDist,
            lastUpdated: new Date().toISOString()
        };
    } catch (error) {
        console.error('í†µê³„ ì¡°íšŒ ì‹¤íŒ¨:', error);
        return null;
    }
}

/**
 * íŠ¹ì • ì œí’ˆì˜ ì·¨ì•½ì  ìš”ì•½
 */
export async function getProductVulnerabilitySummary(productName) {
    try {
        const result = await cveDb.searchByFilters({ product: productName }, 1, 50);

        if (result.total === 0) {
            return `${productName}ì— ëŒ€í•œ CVE ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.`;
        }

        const critical = result.rows.filter(c => c.severity === 'CRITICAL').length;
        const high = result.rows.filter(c => c.severity === 'HIGH').length;
        const medium = result.rows.filter(c => c.severity === 'MEDIUM').length;
        const low = result.rows.filter(c => c.severity === 'LOW').length;

        return `**${productName} ì·¨ì•½ì  ìš”ì•½**
- ì´ CVE ìˆ˜: ${result.total}ê°œ
- CRITICAL: ${critical}ê°œ
- HIGH: ${high}ê°œ
- MEDIUM: ${medium}ê°œ
- LOW: ${low}ê°œ

ìµœê·¼ ì£¼ìš” ì·¨ì•½ì :
${result.rows.slice(0, 5).map((cve, idx) =>
            `${idx + 1}. ${cve.cveId} - ${cve.severity} (CVSS ${cve.cvssScore})`
        ).join('\n')}`;

    } catch (error) {
        console.error('ì œí’ˆ ìš”ì•½ ì‹¤íŒ¨:', error);
        return 'ìš”ì•½ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';
    }
}

/**
 * ë ˆê±°ì‹œ í˜¸í™˜ì„±ì„ ìœ„í•œ ê¸°ë³¸ callVLLM í•¨ìˆ˜ (Ollama ë²„ì „)
 */
export async function callVLLM(prompt, options = {}) {
    const {
        baseURL = config.vllmApiUrl,
        model = config.vllmModel,
        temperature = 0.7,
        maxTokens = 500,
        systemPrompt = 'You are a helpful assistant.'
    } = options;

    try {
        const fullPrompt = `${systemPrompt}\n\nì‚¬ìš©ì: ${prompt}\nì–´ì‹œìŠ¤í„´íŠ¸:`;
        
        const response = await fetch(`${baseURL}/generate`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                model: model,
                prompt: fullPrompt,
                stream: false,
                options: {
                    temperature: temperature,
                    num_predict: maxTokens
                }
            })
        });

        if (!response.ok) {
            throw new Error(`Ollama API Error: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();
        const content = data.response;

        if (!content) {
            throw new Error('No content in Ollama response');
        }

        return content;

    } catch (error) {
        console.error('âŒ Ollama API í˜¸ì¶œ ì‹¤íŒ¨:', error.message);
        throw error;
    }
}
