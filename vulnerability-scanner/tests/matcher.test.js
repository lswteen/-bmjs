import { VulnerabilityMatcher } from '../src/matcher.js';

describe('VulnerabilityMatcher', () => {
    let matcher;

    beforeEach(() => {
        matcher = new VulnerabilityMatcher();
    });

    describe('isVersionAffected', () => {
        it('should match exact version', () => {
            const range = {
                version: '1.2.3',
                status: 'affected',
                versionType: 'semver'
            };
            expect(matcher.isVersionAffected('1.2.3', [range])).toBe(true);
        });

        it('should match lessThanOrEqual', () => {
            const range = {
                lessThanOrEqual: '3.2.1',
                status: 'affected',
                version: '1.0.0', // Start version
                versionType: 'semver',
                range: '>=1.0.0 <=3.2.1'
            };
            // 2.0.0 is between 1.0.0 and 3.2.1
            expect(matcher.isVersionAffected('2.0.0', [range])).toBe(true);
            // 3.2.1 is equal
            expect(matcher.isVersionAffected('3.2.1', [range])).toBe(true);
            // 3.2.2 is greater
            expect(matcher.isVersionAffected('3.2.2', [range])).toBe(false);
        });

        it('should match lessThan', () => {
            const range = {
                lessThan: '2.0.0',
                status: 'affected',
                version: '1.0.0',
                versionType: 'semver',
                range: '>=1.0.0 <2.0.0'
            };
            expect(matcher.isVersionAffected('1.9.9', [range])).toBe(true);
            expect(matcher.isVersionAffected('2.0.0', [range])).toBe(false);
        });

        it('should handle single version range (no upper bound)', () => {
            // Sometimes only 'start' is given? Usually lessThan is there.
            // If only version is there, it implies exact match usually in CSAF/CVE
            // But our logic handles ranges.
        });
    });
});
